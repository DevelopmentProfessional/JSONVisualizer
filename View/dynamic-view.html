<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic D3.js Visualizer - APIRunner</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.css" rel="stylesheet">
    <style>
        .cursor-col-resize { cursor: col-resize; }
    </style>
</head>
<body class="bg-dark overflow-hidden">
    <div class="d-flex vh-100">
        <!-- Preview Panel (Data Explorer) -->
        <div class="bg-secondary bg-opacity-25 border-end border-secondary d-flex flex-column overflow-hidden" style="width: 400px; min-width: 300px; max-width: 600px; resize: horizontal;">
            <div class="p-2 bg-secondary border-bottom border-secondary flex-shrink-0">
                <h6 class="mb-2">Data Explorer</h6>
                <div class="input-group input-group-sm">
                    <span class="input-group-text"><i class="bi bi-search"></i></span>
                    <input type="text" id="searchBox" class="form-control" placeholder="Search data..." oninput="handleSearchInput(this.value)">
                </div>
            </div>
            <div class="flex-fill overflow-auto p-2">
                <!-- Tree visualization will be rendered here -->
                <div id="data-tree-container"></div>
                
                <!-- Debug info -->
                <div class="mt-3">
                    <small class="text-muted" id="debug-info">Loading data...</small>
                </div>
            </div>
        </div>
        
        <!-- Resizer -->
        <div class="bg-secondary cursor-col-resize" style="width: 4px;" id="panel-resizer" onmouseenter="this.classList.add('bg-primary')" onmouseleave="this.classList.remove('bg-primary')"></div>
        
        <!-- Main Visualization Area -->
        <div class="flex-fill d-flex flex-column bg-dark overflow-hidden">
            <div class="p-3 bg-secondary border-bottom border-secondary flex-shrink-0 d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-0">Dynamic D3.js Visualizer</h5>
                    <small class="text-muted">Select variables from the data explorer and map them to graph inputs</small>
                </div>
                <div>
                    <button class="btn btn-sm btn-outline-primary" onclick="resetConfiguration()">
                        <i class="bi bi-arrow-clockwise"></i> Reset
                    </button>
                    <button class="btn btn-sm btn-primary" onclick="renderCurrentGraph()">
                        <i class="bi bi-play-fill"></i> Render
                    </button>
                </div>
            </div>
            
            <div class="flex-fill position-relative overflow-hidden">
                <!-- Visualization Container -->
                <div id="visualization-container" class="w-100 h-100 position-relative"></div>
                
                <!-- Graph Controls Panel -->
                <div class="position-absolute top-0 end-0 m-2 bg-dark bg-opacity-75 border border-secondary rounded" style="width: 320px; max-height: calc(100vh - 120px); z-index: 1000;">
                    <!-- Graph Type Selection -->
                    <div class="p-3 border-bottom border-secondary">
                        <h6 class="mb-2">Graph Type</h6>
                        <select id="graph-type-select" class="form-select" onchange="handleGraphTypeChange(this.value)">
                            <option value="">Select Graph Type...</option>
                        </select>
                    </div>
                    
                    <!-- Selected Variables -->
                    <div class="p-3 border-bottom border-secondary">
                        <h6 class="mb-2">Selected Variables</h6>
                        <div class="border border-2 border-dashed border-secondary rounded p-2 mb-2 bg-secondary bg-opacity-25" style="min-height: 100px;" id="selected-variables">
                            <div class="text-center text-muted py-3">
                                <i class="bi bi-plus-circle"></i><br>
                                Click <i class="bi bi-plus-circle-fill text-primary"></i> buttons in the data tree to add variables
                            </div>
                        </div>
                        <button class="btn btn-sm btn-outline-secondary w-100" onclick="clearSelectedVariables()">
                            <i class="bi bi-trash"></i> Clear All
                        </button>
                    </div>
                    
                    <!-- Variable Mapping -->
                    <div class="p-3 overflow-auto" id="mapping-section" style="max-height: 300px;">
                        <h6 class="mb-2">Variable Mapping</h6>
                        <div id="mapping-areas"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
 

    <script type="module">
        // Import graph registry
        import graphRegistry from './../graphs/registry.js';
        
        // Global state
        let currentData = null;
        let currentGraphType = null;
        let selectedVariables = [];
        let variableMappings = {};
        let dataTreeFlat = [];
        
        // Initialize the application
        async function initializeApp() {
             
            try {
                // Load configuration
                await loadConfiguration();
                
                // Load data
                await loadData();
                
                // Initialize graph type selector
                initializeGraphTypeSelector();
                
                // Initialize drag and drop
                initializeDragAndDrop();
                
                // Initialize panel resizer
                initializePanelResizer();
                
                // Render data tree
                renderDataTree();
                
                 
            } catch (error) {
                 updateDebugInfo('Error: ' + error.message);
            }
        }
        
        // Load configuration from GraphConf.json
        async function loadConfiguration() {
            try {
                const response = await fetch('../data/GraphConf.json');
                if (response.ok) {
                    const config = await response.json();
                    selectedVariables = config.selectedVariables || [];
                    currentGraphType = config.activeGraphType || null;
                    variableMappings = config.graphMappings || {};
                    
                 }
            } catch (error) {
             }
        }
        
 
        
        // Process data for visualization (similar to existing logic)
        function processDataForVisualization(data) {
            if (Array.isArray(data)) {
                // For array data, use the actual API response data
                return data.map(item => item.data || item).filter(item => item);
            } else {
                return data;
            }
        }
        
        // Initialize graph type selector
        function initializeGraphTypeSelector() {
            const select = document.getElementById('graph-type-select');
            const availableGraphs = graphRegistry.getAvailableGraphs();
            
            // Clear existing options
            select.innerHTML = '<option value="">Select Graph Type...</option>';
            
            // Add graph options
            availableGraphs.forEach(graph => {
                const option = document.createElement('option');
                option.value = graph.type;
                option.textContent = `${graph.name} - ${graph.description}`;
                select.appendChild(option);
            });
            
            // Set current selection
            if (currentGraphType) {
                select.value = currentGraphType;
                handleGraphTypeChange(currentGraphType);
            }
        }
        
        // Handle graph type change
        window.handleGraphTypeChange = function(graphType) {
            currentGraphType = graphType;
             
            if (graphType) {
                showMappingSection(graphType);
            } else {
                hideMappingSection();
            }
            
            saveConfiguration();
        };
        
        // Show mapping section for selected graph type
        function showMappingSection(graphType) {
            const section = document.getElementById('mapping-section');
            const mappingAreasContainer = document.getElementById('mapping-areas');
            
            section.classList.remove('d-none');
            mappingAreasContainer.innerHTML = '';
            
            const requirements = graphRegistry.getInputRequirements(graphType);
            if (!requirements) return;
            
            // Create mapping areas for required inputs
            requirements.required.forEach(input => {
                createMappingArea(input, true);
            });
            
            // Create mapping areas for optional inputs
            requirements.optional.forEach(input => {
                createMappingArea(input, false);
            });
        }
        
        // Hide mapping section
        function hideMappingSection() {
            const section = document.getElementById('mapping-section');
            section.classList.add('d-none');
        }
        
        // Create a mapping area for an input
        function createMappingArea(input, isRequired) {
            const container = document.getElementById('mapping-areas');
            
            const mappingDiv = document.createElement('div');
            mappingDiv.className = `border border-2 border-dashed rounded p-2 mb-2 bg-dark bg-opacity-50 ${isRequired ? 'border-danger' : 'border-secondary'}`;
            mappingDiv.style.minHeight = '50px';
            mappingDiv.style.transition = 'all 0.2s';
            mappingDiv.dataset.role = input.role;
            
            const currentMapping = variableMappings[currentGraphType]?.[input.role];
            const mappedVariable = selectedVariables.find(v => v.id === currentMapping);
            
            mappingDiv.innerHTML = `
                <div class="d-flex justify-content-between align-items-start">
                    <div>
                        <strong>${input.name} ${isRequired ? '<span class="text-danger">*</span>' : ''}</strong>
                        <br><small class="text-muted">${input.description}</small>
                    </div>
                    <button class="btn btn-sm btn-outline-danger d-none" onclick="clearMapping('${input.role}')">
                        <i class="bi bi-x"></i>
                    </button>
                </div>
                <div class="mapped-variable mt-2 d-none">
                    <div class="d-flex justify-content-between align-items-center p-2 bg-secondary rounded">
                        <div>
                            <span class="variable-name fw-bold"></span>
                            <br><small class="variable-path text-muted"></small>
                        </div>
                    </div>
                </div>
                <div class="drop-hint text-center text-muted py-2">
                    Drop variable here
                </div>
            `;
            
            // Show existing mapping if any
            if (mappedVariable) {
                showMappedVariable(mappingDiv, mappedVariable);
            }
            
            container.appendChild(mappingDiv);
            setupDropZone(mappingDiv);
        }
        
        // Continue implementation...
        
        // Show mapped variable in mapping area
        function showMappedVariable(mappingArea, variable) {
            const mappedVarDiv = mappingArea.querySelector('.mapped-variable');
            const dropHint = mappingArea.querySelector('.drop-hint');
            const clearBtn = mappingArea.querySelector('button');
            
            mappedVarDiv.style.display = 'block';
            dropHint.style.display = 'none';
            clearBtn.style.display = 'block';
            mappingArea.classList.remove('border-danger', 'border-secondary');
            mappingArea.classList.add('border-success');
            
            mappedVarDiv.querySelector('.variable-name').textContent = variable.displayName;
            mappedVarDiv.querySelector('.variable-path').textContent = variable.path;
        }
        
        // Clear mapping
        window.clearMapping = function(role) {
            if (currentGraphType && variableMappings[currentGraphType]) {
                variableMappings[currentGraphType][role] = null;
            }
            
            const mappingArea = document.querySelector(`[data-role="${role}"]`);
            if (mappingArea) {
                const mappedVarDiv = mappingArea.querySelector('.mapped-variable');
                const dropHint = mappingArea.querySelector('.drop-hint');
                const clearBtn = mappingArea.querySelector('button');
                const isRequired = mappingArea.innerHTML.includes('text-danger');
                
                mappedVarDiv.style.display = 'none';
                dropHint.style.display = 'block';
                clearBtn.style.display = 'none';
                mappingArea.classList.remove('border-success');
                mappingArea.classList.add(isRequired ? 'border-danger' : 'border-secondary');
            }
            
            saveConfiguration();
        };
        
        // Setup drop zone for mapping area
        function setupDropZone(mappingArea) {
            mappingArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                mappingArea.classList.add('border-primary', 'bg-primary', 'bg-opacity-10');
            });
            
            mappingArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                mappingArea.classList.remove('border-primary', 'bg-primary', 'bg-opacity-10');
            });
            
            mappingArea.addEventListener('drop', (e) => {
                e.preventDefault();
                mappingArea.classList.remove('border-primary', 'bg-primary', 'bg-opacity-10');
                
                const variableId = e.dataTransfer.getData('text/plain');
                const variable = selectedVariables.find(v => v.id === variableId);
                
                if (variable) {
                    const role = mappingArea.dataset.role;
                    
                    // Initialize mapping object if needed
                    if (!variableMappings[currentGraphType]) {
                        variableMappings[currentGraphType] = {};
                    }
                    
                    variableMappings[currentGraphType][role] = variableId;
                    showMappedVariable(mappingArea, variable);
                    saveConfiguration();
                    
                 }
            });
        }
        
        // Initialize drag and drop for variable list
        function initializeDragAndDrop() {
            const variableList = document.getElementById('selected-variables');
            
            new Sortable(variableList, {
                group: {
                    name: 'variables',
                    pull: 'clone',
                    put: false
                },
                sort: true,
                onStart: function(evt) {
                    evt.item.classList.add('dragging');
                },
                onEnd: function(evt) {
                    evt.item.classList.remove('dragging');
                }
            });
        }
        
        // Initialize panel resizer
        function initializePanelResizer() {
            const resizer = document.getElementById('panel-resizer');
            const previewPanel = document.querySelector('.preview-panel');
            
            let isResizing = false;
            
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const newWidth = e.clientX;
                if (newWidth >= 300 && newWidth <= 600) {
                    previewPanel.style.width = newWidth + 'px';
                }
            }
            
            function stopResize() {
                isResizing = false;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }
        
        // Render data tree in preview panel
        function renderDataTree() {
            if (!currentData) return;
            
             
            const container = document.getElementById('data-tree-container');
            container.innerHTML = '';
            
            // Flatten data structure for tree rendering
            dataTreeFlat = flattenDataStructure(currentData);
             
            // Create simple tree structure
            const treeDiv = document.createElement('div');
            treeDiv.className = 'tree-structure';
            
            // Render tree nodes
            dataTreeFlat.forEach((node, index) => {
                if (node.depth === 0) {
                    const nodeElement = createTreeNode(node, index);
                    treeDiv.appendChild(nodeElement);
                }
            });
            
            container.appendChild(treeDiv);
        }
        
        // Flatten data structure for exploration
        function flattenDataStructure(data, prefix = '$', depth = 0, maxDepth = 5) {
            const flattened = [];
            
            if (depth > maxDepth) return flattened;
            
            if (Array.isArray(data)) {
                // Add array node
                flattened.push({
                    path: prefix,
                    key: prefix.split('.').pop() || 'root',
                    value: `Array[${data.length}]`,
                    type: 'array',
                    depth: depth,
                    hasChildren: data.length > 0
                });
                
                // Add array items (sample first few)
                const sampleSize = Math.min(data.length, 3);
                for (let i = 0; i < sampleSize; i++) {
                    const itemPath = `${prefix}[${i}]`;
                    if (typeof data[i] === 'object' && data[i] !== null) {
                        flattened.push(...flattenDataStructure(data[i], itemPath, depth + 1, maxDepth));
                    } else {
                        flattened.push({
                            path: itemPath,
                            key: `[${i}]`,
                            value: String(data[i]),
                            type: typeof data[i],
                            depth: depth + 1,
                            hasChildren: false
                        });
                    }
                }
                
                if (data.length > sampleSize) {
                    flattened.push({
                        path: `${prefix}[...]`,
                        key: `... ${data.length - sampleSize} more items`,
                        value: '',
                        type: 'placeholder',
                        depth: depth + 1,
                        hasChildren: false
                    });
                }
                
            } else if (typeof data === 'object' && data !== null) {
                // Add object node
                const keys = Object.keys(data);
                flattened.push({
                    path: prefix,
                    key: prefix.split('.').pop() || 'root',
                    value: `Object{${keys.length} keys}`,
                    type: 'object',
                    depth: depth,
                    hasChildren: keys.length > 0
                });
                
                // Add object properties
                keys.forEach(key => {
                    const value = data[key];
                    const childPath = prefix === '$' ? `$.${key}` : `${prefix}.${key}`;
                    
                    if (typeof value === 'object' && value !== null) {
                        flattened.push(...flattenDataStructure(value, childPath, depth + 1, maxDepth));
                    } else {
                        flattened.push({
                            path: childPath,
                            key: key,
                            value: String(value),
                            type: typeof value,
                            depth: depth + 1,
                            hasChildren: false
                        });
                    }
                });
                
            } else {
                // Primitive value
                flattened.push({
                    path: prefix,
                    key: prefix.split('.').pop() || 'value',
                    value: String(data),
                    type: typeof data,
                    depth: depth,
                    hasChildren: false
                });
            }
            
            return flattened;
        }
        
        // Create tree node element
        function createTreeNode(node, index) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'd-flex align-items-center p-2 rounded mb-1';
            nodeDiv.style.marginLeft = (node.depth * 20) + 'px';
            nodeDiv.style.cursor = 'pointer';
            
            const typeIcon = getTypeIcon(node.type);
            const addButton = node.type !== 'placeholder' ? 
                `<button class="btn btn-outline-primary btn-sm ms-2" onclick="addVariable('${node.path}', '${escapeHtml(node.key)}')" title="Add as variable">
                    <i class="bi bi-plus-circle-fill"></i>
                </button>` : '';
            
            nodeDiv.innerHTML = `
                <i class="bi ${typeIcon} me-2"></i>
                <div class="flex-grow-1">
                    <strong>${escapeHtml(node.key)}</strong>
                    ${node.value ? `<span class="text-muted ms-2">${escapeHtml(truncateString(node.value, 50))}</span>` : ''}
                    <br><small class="text-muted">${node.path}</small>
                </div>
                ${addButton}
            `;
            
            return nodeDiv;
        }
        
        // Get icon for data type
        function getTypeIcon(type) {
            const icons = {
                'object': 'bi-braces',
                'array': 'bi-list-ul',
                'string': 'bi-type',
                'number': 'bi-123',
                'boolean': 'bi-toggle-on',
                'null': 'bi-dash-circle',
                'undefined': 'bi-question-circle',
                'placeholder': 'bi-three-dots'
            };
            return icons[type] || 'bi-file-text';
        }
        
        // Add variable to selection
        window.addVariable = function(path, key) {
            const variableId = 'var_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            const variable = {
                id: variableId,
                path: path,
                displayName: key,
                originalKey: key
            };
            
            selectedVariables.push(variable);
            updateSelectedVariablesList();
            saveConfiguration();
             
        };
        
        // Update selected variables list
        function updateSelectedVariablesList() {
            const container = document.getElementById('selected-variables');
            
            if (selectedVariables.length === 0) {
                container.innerHTML = `
                    <div class="text-center text-muted py-3">
                        <i class="bi bi-plus-circle"></i><br>
                        Click <i class="bi bi-plus-circle-fill text-primary"></i> buttons in the data tree to add variables
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            selectedVariables.forEach(variable => {
                const variableDiv = document.createElement('div');
                variableDiv.className = 'd-flex justify-content-between align-items-center p-2 mb-1 bg-secondary rounded';
                variableDiv.style.cursor = 'move';
                variableDiv.style.userSelect = 'none';
                variableDiv.draggable = true;
                variableDiv.dataset.variableId = variable.id;
                
                variableDiv.innerHTML = `
                    <div>
                        <strong>${escapeHtml(variable.displayName)}</strong>
                        <br><small class="text-muted">${escapeHtml(variable.path)}</small>
                    </div>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeVariable('${variable.id}')">
                        <i class="bi bi-x"></i>
                    </button>
                `;
                
                // Add drag event listeners
                variableDiv.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', variable.id);
                    variableDiv.style.opacity = '0.5';
                });
                
                variableDiv.addEventListener('dragend', () => {
                    variableDiv.style.opacity = '1';
                });
                
                // Add hover effect
                variableDiv.addEventListener('mouseenter', () => {
                    variableDiv.classList.add('bg-secondary', 'bg-opacity-75');
                });
                
                variableDiv.addEventListener('mouseleave', () => {
                    variableDiv.classList.remove('bg-opacity-75');
                });
                
                container.appendChild(variableDiv);
            });
        }
        
        // Remove variable
        window.removeVariable = function(variableId) {
            selectedVariables = selectedVariables.filter(v => v.id !== variableId);
            
            // Remove from all mappings
            Object.keys(variableMappings).forEach(graphType => {
                Object.keys(variableMappings[graphType]).forEach(role => {
                    if (variableMappings[graphType][role] === variableId) {
                        variableMappings[graphType][role] = null;
                    }
                });
            });
            
            updateSelectedVariablesList();
            
            // Refresh mapping section if active
            if (currentGraphType) {
                showMappingSection(currentGraphType);
            }
            
            saveConfiguration();
        };
        
        // Clear all selected variables
        window.clearSelectedVariables = function() {
            selectedVariables = [];
            variableMappings = {};
            updateSelectedVariablesList();
            
            if (currentGraphType) {
                showMappingSection(currentGraphType);
            }
            
            saveConfiguration();
        };
        
        // Render current graph
        window.renderCurrentGraph = async function() {
            if (!currentGraphType) {
                alert('Please select a graph type first');
                return;
            }
            
            if (!currentData) {
                alert('No data available for rendering');
                return;
            }
            
            const mappings = variableMappings[currentGraphType] || {};
            
            // Validate mappings
            const validation = graphRegistry.validateMappings(currentGraphType, mappings);
            if (!validation.valid) {
                alert('Invalid mappings:\n' + validation.errors.join('\n'));
                return;
            }
            
            if (validation.warnings.length > 0) {
             }
            
            try {
                const container = document.getElementById('visualization-container');
                
                // Convert variable IDs to actual paths in mappings
                const resolvedMappings = {};
                Object.keys(mappings).forEach(role => {
                    if (mappings[role]) {
                        const variable = selectedVariables.find(v => v.id === mappings[role]);
                        if (variable) {
                            resolvedMappings[role] = variable.path;
                        }
                    }
                });
                
                 
                await graphRegistry.loadAndRender(
                    currentGraphType,
                    container,
                    currentData,
                    resolvedMappings,
                    { width: container.offsetWidth, height: container.offsetHeight }
                );
                
            } catch (error) {
                 alert('Error rendering graph: ' + error.message);
            }
        };
        
        // Save configuration
        async function saveConfiguration() {
            const config = {
                selectedVariables: selectedVariables,
                activeGraphType: currentGraphType,
                graphMappings: variableMappings,
                timestamp: new Date().toISOString()
            };
            
            try {
                const response = await fetch('/UpdateGraphConfiguration', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                if (response.ok) { 
                } else { 
                }
            } catch (error) { 
            }
        }
        
        // Reset configuration
        window.resetConfiguration = function() {
            if (confirm('Reset all configuration? This will clear all selected variables and mappings.')) {
                selectedVariables = [];
                variableMappings = {};
                currentGraphType = null;
                
                document.getElementById('graph-type-select').value = '';
                updateSelectedVariablesList();
                hideMappingSection();
                document.getElementById('visualization-container').innerHTML = '';
                
                saveConfiguration();
            }
        };
        
        // Handle search input
        window.handleSearchInput = function(searchTerm) {
            // Filter tree nodes based on search term
            const treeNodes = document.querySelectorAll('#data-tree-container > .tree-structure > div');
            
            treeNodes.forEach(node => {
                const text = node.textContent.toLowerCase();
                if (searchTerm === '' || text.includes(searchTerm.toLowerCase())) {
                    node.style.display = 'flex';
                } else {
                    node.style.display = 'none';
                }
            });
        };
        
        // Update debug info
        function updateDebugInfo(message) {
            document.getElementById('debug-info').textContent = message;
        }
        
        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function truncateString(str, maxLength) {
            if (str.length <= maxLength) return str;
            return str.substring(0, maxLength) + '...';
        }
        
        // Make functions globally available
        window.initializeApp = initializeApp;
        window.updateDebugInfo = updateDebugInfo;
        window.renderCurrentGraph = renderCurrentGraph;
        window.resetConfiguration = resetConfiguration;
        window.clearSelectedVariables = clearSelectedVariables;
        window.clearMapping = clearMapping;
        window.handleSearchInput = handleSearchInput;
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
        
    </script>
</body>
</html>
