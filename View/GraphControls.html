<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Controls - JSON Visualizer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        /* Custom utility classes for dynamic popup content */
        .popup-header { color: #fff; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 6px; }
        .popup-field-info { margin-bottom: 12px; padding: 6px; background: #1a1a1a; border-radius: 4px; border: 1px solid #666; }
        .popup-field-details { color: #ccc; font-size: 11px; margin-bottom: 2px; }
        .popup-array-source { margin-bottom: 12px; padding: 8px; background: #1a1a1a; border-radius: 4px; border: 1px solid #ffc107; }
        .popup-array-header { color: #ffc107; font-size: 12px; font-weight: bold; margin-bottom: 4px; }
        .popup-array-desc { font-size: 11px; color: #ccc; }
        .popup-section { margin-bottom: 8px; }
        .popup-section-header { font-size: 12px; font-weight: bold; margin-bottom: 4px; }
        .popup-required-header { color: #dc3545; }
        .popup-optional-header { color: #17a2b8; }
        .popup-field-desc { font-size: 11px; }
        .popup-field-req { font-size: 10px; margin-top: 2px; }
        .popup-field-warning { font-size: 10px; color: #ff9999; margin-top: 2px; }
        .popup-field-mapped { font-size: 10px; color: #000; margin-top: 2px; }
        .popup-footer { border-top: 1px solid #444; padding-top: 8px; margin-top: 8px; }
        .cursor-grab { cursor: grab; }
        .cursor-col-resize { cursor: col-resize; }
        
        /* Range input width utilities */
        .w-range-sm { width: 60px; }
        .w-range-md { width: 80px; }
    </style>
</head>
<body class="bg-dark text-light">
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-secondary border-bottom border-secondary">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="#">
                <i class="bi bi-graph-up"></i> JSON Visualizer - Graph Controls
            </a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link text-light" href="Graph.html">
                    <i class="bi bi-eye"></i> View Charts
                </a>
                <a class="nav-link active" href="GraphControls.html">
                    <i class="bi bi-sliders"></i> Graph Controls
                </a>
                <a class="nav-link" href="admin.html">
                    <i class="bi bi-gear"></i> Admin
                </a>
            </div>
        </div>
    </nav>

    <!-- Status Indicator -->
    <div id="statusIndicator" class="position-fixed p-3 rounded opacity-0" style="top: 80px; right: 20px; z-index: 1001; transition: opacity 0.3s ease;"></div>

    <!-- Main Container -->
    <div class="d-flex vh-100 overflow-hidden">
        <!-- Left Panel -->
        <div class="bg-dark bg-opacity-75 border-end border-secondary p-3 overflow-auto" style="width: 350px; min-width: 300px; max-width: 450px; resize: horizontal;">
            <!-- Data Source Section -->
            <div class="card bg-secondary mb-3">
                <div class="card-header bg-dark">
                    <i class="bi bi-database"></i> Data Source
                </div>
                <div class="card-body">
                    <div class="input-group input-group-sm mb-3">
                        <span class="input-group-text">API Response</span>
                        <select id="apiResponseSelector" class="form-select" onchange="loadSelectedApiResponse()">
                            <option value="">-- Select API Response --</option>
                        </select>
                    </div>
                    <div class="input-group input-group-sm mb-3">
                        <span class="input-group-text">Existing Mapping</span>
                        <select id="existingMappingSelector" class="form-select" onchange="loadExistingMappingForEdit()" disabled>
                            <option value="">-- None / New Mapping --</option>
                        </select>
                    </div>
                    <div class="mb-2">
                        <small class="text-muted">
                            <i class="bi bi-info-circle"></i> 
                            Select the API response file to visualize
                        </small>
                    </div>
                </div>
            </div>

            <!-- Visualization Configuration Section -->
            <div class="card bg-secondary mb-3">
                <div class="card-header bg-dark">
                    <i class="bi bi-bar-chart"></i> Visualization
                </div>
                <div class="card-body">
                    <div class="input-group input-group-sm mb-3">
                        <span class="input-group-text">Graph Type</span>
                        <select id="graphTypeSelector" class="form-select" onchange="selectGraphType()">
                            <option value="">-- Select Graph Type --</option>
                            <option value="tree">Tree (Hierarchical)</option>
                            <option value="force-directed">Force-Directed Network</option>
                            <option value="bar-chart">Bar Chart</option>
                            <option value="world-map">World Map</option>
                        </select>
                    </div>

                    <!-- Graph Input Mappings -->
                    <div id="graphInputMappings">
                        <div class="mb-2">
                            <label class="form-label small">Field Mappings:</label>
                        </div>
                        <div id="mappingControls"></div>
                        
                        <!-- Variables Preview Table -->
                        <div id="variablesPreview" class="bg-dark bg-opacity-50 rounded p-3 mt-3 overflow-auto d-none" style="max-height: 300px;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <strong>Selected Variables Preview</strong>
                                <button class="btn btn-sm btn-outline-secondary" onclick="clearAllMappings()">
                                    <i class="bi bi-x"></i> Clear All
                                </button>
                            </div>
                            <div id="variablesTable"></div>
                        </div>
                    </div>

                    <div class="mt-3">
                        <div class="d-grid gap-2">
                            <button id="previewBtn" class="btn btn-outline-info btn-sm" onclick="previewMappings()" disabled>
                                <i class="bi bi-eye"></i> Preview Mappings
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- JSON Explorer Container -->
        <div class="flex-fill d-flex flex-column">
            
                <div class="d-flex justify-content-between align-items-center">
                    <h4 class="mb-0">
                        <i class="bi bi-list-nested"></i> JSON Explorer
                    </h4>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-light" onclick="expandAllExplorerNodes()" title="Expand All">
                            <i class="bi bi-chevron-expand"></i>
                        </button>
                        <button class="btn btn-outline-light" onclick="collapseAllExplorerNodes()" title="Collapse All">
                            <i class="bi bi-chevron-contract"></i>
                        </button>
                        <button class="btn btn-outline-light" onclick="centerExplorerView()" title="Center View">
                            <i class="bi bi-bullseye"></i>
                        </button>
                    </div>
                </div>
            
            <div class="flex-fill overflow-hidden p-3">
                <!-- Advanced Controls (Initially Hidden) -->
                <div id="advancedExplorerControls" class="mb-3">
                    <div class="row g-2">
                        <div class="col-md-3">
                            <label class="form-label small">Node Spacing:</label>
                            <div class="d-flex align-items-center">
                                <input type="range" id="explorerSpacingSlider" class="form-range me-2 w-range-md" min="50" max="500" value="100" step="10" oninput="updateExplorerSpacing(this.value)">
                                <small id="explorerSpacingValue" class="text-muted">100</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label small">Vertical Spacing:</label>
                            <div class="d-flex align-items-center">
                                <input type="range" id="explorerVerticalSpacingSlider" class="form-range me-2 w-range-md" min="20" max="300" value="40" step="5" oninput="updateExplorerVerticalSpacing(this.value)">
                                <small id="explorerVerticalSpacingValue" class="text-muted">40</small>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label small">Text Size:</label>
                            <div class="d-flex align-items-center">
                                <input type="range" id="explorerTextSizeSlider" class="form-range me-2 w-range-sm" min="8" max="20" value="11" step="1" oninput="updateExplorerTextSize(this.value)">
                                <small id="explorerTextSizeValue" class="text-muted">11</small>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label small">Max Depth:</label>
                            <div class="d-flex align-items-center">
                                <input type="range" id="explorerMaxDepthSlider" class="form-range me-2 w-range-sm" min="2" max="10" value="8" step="1" oninput="updateExplorerMaxDepth(this.value)">
                                <small id="explorerMaxDepthValue" class="text-muted">8</small>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label small">Node Size:</label>
                            <div class="d-flex align-items-center">
                                <input type="range" id="explorerNodeSizeSlider" class="form-range me-2 w-range-sm" min="3" max="20" value="6" step="1" oninput="updateExplorerNodeSize(this.value)">
                                <small id="explorerNodeSizeValue" class="text-muted">6</small>
                            </div>
                        </div>
                    </div>
                    <div class="row g-2 mt-2">
                        <div class="col-md-2">
                            <label class="form-label small">Orientation</label>
                            <select id="explorerOrientationSelect" class="form-select form-select-sm" onchange="updateExplorerOrientation(this.value)">
                                <option value="vertical">Vertical</option>
                                <option value="horizontal">Horizontal</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label small">Tree Shape</label>
                            <select id="explorerTreeShapeSelect" class="form-select form-select-sm" onchange="updateExplorerTreeShape(this.value)">
                                <option value="tree">Tree</option>
                                <option value="cluster">Cluster</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label small">Link Style</label>
                            <select id="explorerLinkStyleSelect" class="form-select form-select-sm" onchange="updateExplorerLinkStyle(this.value)">
                                <option value="curved">Curved</option>
                                <option value="straight">Straight</option>
                                <option value="elbow">Elbow</option>
                            </select>
                        </div>
                        <div class="col-md-2">
                            <label class="form-label small">Chart Size</label>
                            <div class="d-flex align-items-center">
                                <input type="range" id="explorerChartSizeSlider" class="form-range me-2 w-range-md" min="300" max="1200" value="450" step="50" oninput="updateExplorerChartSize(this.value)">
                                <small id="explorerChartSizeValue" class="text-muted">450</small>
                            </div>
                        </div>
                        <div class="col-md-2 d-flex align-items-end">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="explorerShowLabelsChk" checked onchange="updateExplorerShowLabels(this.checked)">
                                <label class="form-check-label small" for="explorerShowLabelsChk">Show Labels</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- JSON Explorer Chart -->
                <div id="jsonExplorerChart" class="bg-secondary bg-opacity-25 rounded border border-secondary user-select-none w-100 h-100">
                    <div class="d-flex align-items-center justify-content-center h-100 text-muted">
                        <div class="text-center">
                            <i class="bi bi-file-earmark-code display-1"></i>
                            <p class="mt-2">Select an API response to explore its structure</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Mapping Button -->
    <div class="position-fixed bottom-0 end-0 m-3" style="z-index: 1000;">
        <button id="renderBtn" class="btn btn-success btn-lg rounded-pill px-4 py-2 fw-bold shadow" onclick="saveCurrentMapping()" disabled>
            <i class="bi bi-save"></i> Save Mapping
        </button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global variables
        let currentApiData = null;
        let currentGraphType = null;
    // Current in-edit mappings for selected graph type
    let graphMappings = {};
    // All saved mappings per graph type: { graphType: { mappings: {role:path,...} } }
    let savedGraphMappings = {};
        let availableJsonPaths = [];
        let explorerZoom = null;
        let explorerRoot = null;
        let explorerUpdate = null;
        let explorerSpacing = 100;
        let explorerVerticalSpacing = 40;
        let explorerTextSize = 11;
        let explorerMaxDepth = 8;
        // New advanced explorer control variables (from Graphconf.json)
        let explorerNodeSize = 6;
        let explorerOrientation = 'vertical';
        let explorerTreeShape = 'tree';
        let explorerLinkStyle = 'curved';
        let explorerShowLabels = true;
        let explorerChartSize = 450;
        let saveExplorerConfigDebounce = null;
    // Existing mapping management
    let existingDataSourceMappings = {}; // contents of DataSourceMappings.json
    let currentLoadedMappingName = null; // name of mapping loaded for edit

        // Button state updater (re-added)
    function updateRenderButtonState() {
            const renderBtn = document.getElementById('renderBtn');
            const previewBtn = document.getElementById('previewBtn');
            if (!renderBtn || !previewBtn) return;
            const hasData = !!currentApiData;
            const hasGraphType = !!currentGraphType;
            const hasRowPath = !!(graphMappings.rowPath && graphMappings.rowPath.trim() !== '');
            const requiredRolesMap = {
                'tree': ['label'],
                'force-directed': ['source','target'],
                'bar-chart': ['x','y'],
                'world-map': ['longitude','latitude','label']
            };
            let hasRequired = true;
            if (hasGraphType && requiredRolesMap[currentGraphType]) {
                hasRequired = requiredRolesMap[currentGraphType].every(r => graphMappings[r] && graphMappings[r].trim() !== '');
            }
            const canSave = hasData && hasGraphType && hasRowPath && hasRequired;
            renderBtn.disabled = !canSave;
            previewBtn.disabled = !hasData || !hasGraphType || !hasRowPath || Object.keys(graphMappings).filter(k => graphMappings[k] && k !== 'rowPath').length === 0;
        }

        async function saveCurrentMapping() {
            const mappingName = prompt('Enter a name for this mapping configuration:');
            if (!mappingName) return;
            try {
                // Ensure current graph type mapping stored
                if (currentGraphType) {
                    if (!savedGraphMappings[currentGraphType]) savedGraphMappings[currentGraphType] = { mappings: {} };
                    savedGraphMappings[currentGraphType].mappings = { ...graphMappings };
                }
                const dataSourceSelect = document.getElementById('apiResponseSelector');
                const ds = dataSourceSelect.value;
                if (!ds) {
                    alert('Select a data source first.');
                    return;
                }
                const body = {
                    dataSource: ds,
                    mappingName: mappingName.trim(),
                    graphs: savedGraphMappings
                };
                const resp = await fetch('/SaveDataSourceMapping', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (!resp.ok) throw new Error('Save failed');
                const json = await resp.json();
                showStatus(`Saved mapping '${mappingName}' for ${ds}`, 'success');
                currentLoadedMappingName = mappingName.trim();
                // Reload mappings file and refresh selector
                await loadDataSourceMappingsFile();
                populateExistingMappingsSelector(ds);
                const existingSel = document.getElementById('existingMappingSelector');
                if (existingSel) existingSel.value = currentLoadedMappingName;
            } catch (e) {
                showStatus('Save mapping failed: ' + e.message, 'danger');
            }
        }

        async function loadDataSourceMappingsFile() {
            try {
                const resp = await fetch('/data/DataSourceMappings.json?_=' + Date.now());
                if (!resp.ok) return;
                const json = await resp.json();
                existingDataSourceMappings = json.dataSources || {};
                // Refresh selector if a data source already selected
                const dsSel = document.getElementById('apiResponseSelector');
                if (dsSel && dsSel.value) populateExistingMappingsSelector(dsSel.value);
            } catch {}
        }

        function populateExistingMappingsSelector(ds) {
            const sel = document.getElementById('existingMappingSelector');
            if (!sel) return;
            sel.innerHTML = '<option value="">-- None / New Mapping --</option>';
            if (!ds || !existingDataSourceMappings[ds] || !existingDataSourceMappings[ds].mappings) {
                sel.disabled = true; return;
            }
            const entries = Object.keys(existingDataSourceMappings[ds].mappings);
            if (!entries.length) { sel.disabled = true; return; }
            entries.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name; opt.textContent = name;
                sel.appendChild(opt);
            });
            sel.disabled = false;
            if (currentLoadedMappingName && entries.includes(currentLoadedMappingName)) {
                sel.value = currentLoadedMappingName;
            }
        }

        function loadExistingMappingForEdit() {
            const dsSel = document.getElementById('apiResponseSelector');
            const ds = dsSel ? dsSel.value : null;
            const mapSel = document.getElementById('existingMappingSelector');
            const mappingName = mapSel ? mapSel.value : '';
            currentLoadedMappingName = mappingName || null;
            if (!ds || !mappingName || !existingDataSourceMappings[ds]) return; // nothing selected
            const mappingDef = existingDataSourceMappings[ds].mappings[mappingName];
            if (!mappingDef) return;
            savedGraphMappings = {};
            const graphs = mappingDef.graphs || {};
            Object.entries(graphs).forEach(([gType, gConf]) => {
                savedGraphMappings[gType] = { mappings: { ...(gConf.mappings || {}) } };
            });
            const graphTypes = Object.keys(savedGraphMappings);
            if (!graphTypes.includes(currentGraphType)) {
                currentGraphType = graphTypes[0] || null;
                const gtSelector = document.getElementById('graphTypeSelector');
                if (gtSelector && currentGraphType) gtSelector.value = currentGraphType;
            }
            if (currentGraphType) loadGraphMappingControls(currentGraphType, true);
            showStatus(`Loaded mapping '${mappingName}' for editing`, 'info');
            updateRenderButtonState();
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            loadAvailableApiResponses();
            loadSavedConfiguration();
            loadExplorerControlsFromGraphconf();
            loadDataSourceMappingsFile();
            const existingSel = document.getElementById('existingMappingSelector');
            if (existingSel) existingSel.addEventListener('change', loadExistingMappingForEdit);
        });

        // Load available API response files
        async function loadAvailableApiResponses() {
            try {
                const response = await fetch('/data/ApiResponse');
                if (!response.ok) throw new Error('Failed to load API responses');
                
                const files = await response.json();
                const selector = document.getElementById('apiResponseSelector');
                
                selector.innerHTML = '<option value="">-- Select API Response --</option>';
                files.forEach(file => {
                    if (file.endsWith('.json')) {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.replace('.json', '');
                        selector.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Error loading API responses:', error);
                showStatus('Failed to load API responses', 'error');
            }
        }

        // Load selected API response
        async function loadSelectedApiResponse() {
            const selector = document.getElementById('apiResponseSelector');
            const selectedFile = selector.value;
            
            if (!selectedFile) {
                currentApiData = null;
                clearJsonExplorer();
                updateRenderButtonState();
                
                // Clear the data source from mappings
                if (graphMappings.dataSource) {
                    delete graphMappings.dataSource;
                }
                
                return;
            }
            
            try {
                showStatus('Loading API response...', 'info');
                const response = await fetch(`/data/ApiResponse/${selectedFile}`);
                if (!response.ok) throw new Error(`Failed to load ${selectedFile}`);
                
                currentApiData = await response.json();
                displayJsonExplorer(currentApiData);
                updateRenderButtonState();
                
                // Store the data source name for validation
                graphMappings.dataSource = selectedFile;
                // Refresh existing mappings selector for this data source
                populateExistingMappingsSelector(selectedFile);
                
                showStatus('API response loaded successfully', 'success');
            } catch (error) {
                console.error('Error loading API response:', error);
                showStatus(`Failed to load ${selectedFile}`, 'error');
                currentApiData = null;
                clearJsonExplorer();
                updateRenderButtonState();
            }
        }

        // Clear JSON Explorer
        function clearJsonExplorer() {
            const chart = document.getElementById('jsonExplorerChart');
            chart.innerHTML = `
                <div class="d-flex align-items-center justify-content-center h-100 text-muted">
                    <div class="text-center">
                        <i class="bi bi-file-earmark-code display-1"></i>
                        <p class="mt-2">Select an API response to explore its structure</p>
                    </div>
                </div>
            `;
            availableJsonPaths = [];
        }

        // Display JSON structure explorer as D3 hierarchical chart
        function displayJsonExplorer(data) {
            const chartContainer = document.getElementById('jsonExplorerChart');
            availableJsonPaths = [];
            // Adjust chart container size based on explorerChartSize
            chartContainer.style.height = explorerChartSize + 'px';
            
            // Clear existing chart
            d3.select('#jsonExplorerChart').selectAll('*').remove();
            
            // Extract data portion from response
            let explorerData = data;
            if (data && typeof data === 'object') {
                if (data.data) {
                    explorerData = data.data;
                } else if (data.response && data.response.data) {
                    explorerData = data.response.data;
                } else if (data.result) {
                    explorerData = data.result;
                } else if (data.payload) {
                    explorerData = data.payload;
                }
            }
            
            // Build hierarchical data structure
            function buildHierarchy(obj, path = '', depth = 0) {
                if (depth > explorerMaxDepth) return null;
                
                const node = {
                    name: path === '' ? 'root' : path.split('.').pop(),
                    path: path === '' ? 'data' : path,
                    value: null,
                    type: Array.isArray(obj) ? 'array' : typeof obj,
                    children: [],
                    depth: depth
                };
                
                // Add to paths for drag and drop
                if (path) {
                    availableJsonPaths.push({
                        path: path,
                        type: node.type,
                        sample: Array.isArray(obj) ? `[${obj.length} items]` : 
                               typeof obj === 'object' ? '[object]' : 
                               String(obj)
                    });
                }
                
                if (typeof obj === 'object' && obj !== null) {
                    const entries = Array.isArray(obj) ? 
                        obj.slice(0, 5).map((item, i) => [i, item]) : // Show first 5 array items
                        Object.entries(obj);
                        
                    entries.forEach(([key, value]) => {
                        const childPath = path === '' ? String(key) : `${path}.${key}`;
                        const childNode = buildHierarchy(value, childPath, depth + 1);
                        if (childNode) {
                            node.children.push(childNode);
                        }
                    });
                    
                    if (Array.isArray(obj) && obj.length > 5) {
                        node.children.push({
                            name: `... ${obj.length - 5} more items`,
                            path: `${path}[...]`,
                            type: 'placeholder',
                            children: [],
                            depth: depth + 1
                        });
                    }
                } else {
                    node.value = obj;
                }
                
                return node;
            }
            
            const hierarchyData = buildHierarchy(explorerData);
            
            if (!hierarchyData) {
                showStatus('Failed to build hierarchy data', 'error');
                return;
            }
            
            // D3 tree layout
            const containerRect = chartContainer.getBoundingClientRect();
            const width = containerRect.width - 20;
            const height = containerRect.height - 20;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };

            const svg = d3.select('#jsonExplorerChart')
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet')
                .classed('w-100 h-100', true)
                .style('background', '#2d2d2d')
                .style('border-radius', '4px')
                .style('cursor', 'grab');
            
            // Add zoom and pan
            const zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            explorerZoom = zoom;
            svg.call(zoom);
            
            svg.on('mousedown', function() {
                svg.style('cursor', 'grabbing');
            }).on('mouseup', function() {
                svg.style('cursor', 'grab');
            });
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create tree layout
            const treeLayout = d3.tree()
                .size([width - margin.left - margin.right, height - margin.top - margin.bottom]);
            
            treeLayout.separation((a, b) => {
                const baseSpacing = explorerVerticalSpacing / 40;
                return (a.parent === b.parent ? baseSpacing : baseSpacing * 1.5);
            });
            
            const root = d3.hierarchy(hierarchyData);
            explorerRoot = root;
            
            // Initially expand first 2 levels
            root.descendants().forEach(d => {
                if (d.depth < 2) {
                    d._children = null;
                } else {
                    d._children = d.children;
                    d.children = null;
                }
            });
            
            function update(source) {
                // Choose layout based on tree shape
                const layout = (explorerTreeShape === 'cluster' ? d3.cluster() : d3.tree())
                    .size([
                        explorerOrientation === 'vertical' ? (width - margin.left - margin.right) : (height - margin.top - margin.bottom),
                        explorerOrientation === 'vertical' ? (height - margin.top - margin.bottom) : (width - margin.left - margin.right)
                    ]);
                layout.separation((a, b) => {
                    const baseSpacing = explorerVerticalSpacing / 40;
                    return (a.parent === b.parent ? baseSpacing : baseSpacing * 1.5);
                });
                const treeData = layout(root);
                const nodes = treeData.descendants();
                const links = treeData.descendants().slice(1);
                
                // Update node positions
                nodes.forEach(d => {
                    if (explorerOrientation === 'vertical') {
                        d.y = d.depth * explorerSpacing;
                        d.x = d.x * (explorerVerticalSpacing / 40);
                    } else {
                        d.x = d.depth * explorerSpacing;
                        d.y = d.x * (explorerVerticalSpacing / 40); // temporary swapped logic
                    }
                });
                
                // Add links first (behind nodes) - use stable key based on data path
                const link = g.selectAll('.json-link')
                    .data(links, d => (d && d.data && d.data.path) ? d.data.path : `${d.depth}-${d.index}`);
                
                const linkEnter = link.enter().append('path')
                    .attr('class', 'json-link')
                    .style('fill', 'none')
                    .style('stroke', '#666')
                    .style('stroke-width', '1px')
                    .style('opacity', '0.6');
                
                const linkUpdate = linkEnter.merge(link);
                
                linkUpdate.attr('d', d => {
                    const sx = d.parent.x, sy = d.parent.y, tx = d.x, ty = d.y;
                    if (explorerLinkStyle === 'straight') {
                        return `M${sy},${sx}L${ty},${tx}`;
                    } else if (explorerLinkStyle === 'elbow') {
                        return `M${sy},${sx}L${(sy+ty)/2},${sx}L${(sy+ty)/2},${tx}L${ty},${tx}`;
                    } else { // curved
                        return `M${ty},${tx}C${(ty + sy) / 2},${tx} ${(ty + sy) / 2},${sx} ${sy},${sx}`;
                    }
                });
                
                link.exit().remove();
                
                // Add nodes - stable key based on path
                const node = g.selectAll('.json-node')
                    .data(nodes, d => (d && d.data && d.data.path) ? d.data.path : `${d.depth}-${d.index}`);
                
                const nodeEnter = node.enter().append('g')
                    .attr('class', 'json-node')
                    .attr('transform', d => `translate(${d.y},${d.x})`)
                    .style('cursor', 'pointer');
                
                // Add circles
                nodeEnter.append('circle')
                    .attr('r', explorerNodeSize)
                    .style('fill', d => {
                        if (d.data.type === 'object') return '#4fc3f7';
                        if (d.data.type === 'array') return '#ff9800';
                        if (d.data.type === 'string') return '#4caf50';
                        if (d.data.type === 'number') return '#f44336';
                        if (d.data.type === 'boolean') return '#9c27b0';
                        return '#666';
                    })
                    .style('stroke', '#fff')
                    .style('stroke-width', '2px')
                    .style('cursor', 'pointer')
                    .attr('draggable', false); // Explicitly not draggable
                
                // Add expand/collapse indicators (moved to right side)
                const expander = nodeEnter.append('foreignObject')
                    .attr('class', 'expand-indicator')
                    .attr('x', d => {
                        // place to right of text (reuse width logic below). We'll adjust later in update section too.
                        const name = d.data.name === 'root' ? 'data' : d.data.name;
                        let displayText = name;
                        if (d.data.value !== null && d.data.value !== undefined) {
                            const valueStr = String(d.data.value);
                            displayText = valueStr.length > 20 ? `${name}: ${valueStr.substring(0,20)}...` : `${name}: ${valueStr}`;
                        }
                        return 8 + (displayText.length * (explorerTextSize * 0.6)) + 10; // to right of text
                    })
                    .attr('y', -12)
                    .attr('width', 20)
                    .attr('height', 20)
                    .style('cursor', 'pointer')
                    .style('pointer-events', 'all')
                    .html(d => {
                        if (d.children) return '<i class="bi bi-chevron-down" style="color: #ffd700;"></i>';
                        if (d._children) return '<i class="bi bi-arrows-expand" style="color: #ffd700;"></i>';
                        return '';
                    })
                    .each(function() {
                        this.addEventListener('mousedown', e => { e.stopPropagation(); });
                    });
                
                // Add draggable labels
                nodeEnter.append('text')
                    .attr('dy', '0.35em')
                    .attr('x', 8)
                    .style('text-anchor', 'start')
                    .style('font-size', `${explorerTextSize}px`)
                    .style('fill', '#fff')
                    .style('font-family', 'monospace')
                    .style('cursor', 'default')
                    .style('user-select', 'none') // Prevent text selection
                    .style('-webkit-user-select', 'none')
                    .style('-moz-user-select', 'none')
                    .style('-ms-user-select', 'none')
                    .style('pointer-events', 'none') // Disable mouse events on text
                    .text(d => {
                        const name = d.data.name === 'root' ? 'data' : d.data.name;
                        if (d.data.value !== null && d.data.value !== undefined) {
                            const valueStr = String(d.data.value);
                            if (valueStr.length > 20) {
                                return `${name}: ${valueStr.substring(0, 20)}...`;
                            }
                            return `${name}: ${valueStr}`;
                        }
                        return name;
                    });
                
                // Add click handle for non-array, non-object fields (moved to left side next to circle)
                nodeEnter.filter(d => d.data.type !== 'array' && d.data.type !== 'object' && d.data.type !== 'placeholder')
                    .append('foreignObject')
                    .attr('class', 'click-handle')
                    .attr('x', -40) // left side
                    .attr('y', -10)
                    .attr('width', 20)
                    .attr('height', 20)
                    .style('cursor', 'pointer')
                    .style('pointer-events', 'all')
                    .html('<i class="bi bi-plus-square" style="color: #007bff;"></i>')
                    .on('mouseenter', function() { d3.select(this).select('i').style('color', '#0056b3'); })
                    .on('mouseleave', function() { d3.select(this).select('i').style('color', '#007bff'); })
                    .on('click', function(event, d) {
                        event.stopPropagation();
                        const fieldPath = d.data.path;
                        showFieldMappingPopup(fieldPath, event.pageX, event.pageY);
                    });
                
                // Add click handle for array nodes (moved to left side, different color)
                nodeEnter.filter(d => d.data.type === 'array' && d.data.type !== 'placeholder')
                    .append('foreignObject')
                    .attr('class', 'array-click-handle')
                    .attr('x', -40)
                    .attr('y', -10)
                    .attr('width', 20)
                    .attr('height', 20)
                    .style('cursor', 'pointer')
                    .style('pointer-events', 'all')
                    .html('<i class="bi bi-table" style="color: #ffc107;"></i>')
                    .on('mouseenter', function() { d3.select(this).select('i').style('color', '#e0a800'); })
                    .on('mouseleave', function() { d3.select(this).select('i').style('color', '#ffc107'); })
                    .on('click', function(event, d) {
                        event.stopPropagation();
                        const cleanPath = cleanArrayPath(d.data.path);
                        graphMappings.rowPath = cleanPath;
                        let rowPathInput = document.querySelector('[data-role="rowPath"]');
                        if (rowPathInput) { rowPathInput.value = cleanPath; rowPathInput.dispatchEvent(new Event('change')); }
                        updateRenderButtonState();
                        showStatus(`Set ${cleanPath} as row data source`, 'success');
                    });
                
                // Click to expand/collapse - attach to main circles and expand/collapse indicators
                nodeEnter.select('circle').on('click', function(event, d) {
                    event.stopPropagation();
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                });
                
                // Also add click to expand/collapse indicators
                nodeEnter.select('foreignObject').on('click', function(event, d) {
                    event.stopPropagation();
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                });
                
                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.attr('transform', d => `translate(${d.y},${d.x})`);
                
                // Update main circles
                nodeUpdate.select('circle:not(.drag-handle)').attr('r', explorerNodeSize);
                
                // Update click handles position
                nodeUpdate.selectAll('.click-handle')
                    .attr('x', d => {
                        // Recalculate position based on current text size
                        const name = d.data.name === 'root' ? 'data' : d.data.name;
                        let displayText = name;
                        if (d.data.value !== null && d.data.value !== undefined) {
                            const valueStr = String(d.data.value);
                            if (valueStr.length > 20) {
                                displayText = `${name}: ${valueStr.substring(0, 20)}...`;
                            } else {
                                displayText = `${name}: ${valueStr}`;
                            }
                        }
                        return 8 + (displayText.length * (explorerTextSize * 0.6)) + 10 - 8;
                    })
                    .style('display', explorerShowLabels ? null : 'none');
                
                // Update array click handles position
                nodeUpdate.selectAll('.array-click-handle')
                    // Keep the array add button icon anchored to the left of the node circle
                    .attr('x', d => -(explorerNodeSize + 28))
                    .style('display', explorerShowLabels ? null : 'none');
                
                // Update text
                nodeUpdate.selectAll('text')
                    .style('font-size', `${explorerTextSize}px`);
                nodeUpdate.selectAll('text:not(.drag-icon):last-of-type')
                    .style('display', explorerShowLabels ? null : 'none');
                
                node.exit().remove();
            }
            
            explorerUpdate = update;
            update(root);
            
            // Add resize handler to update SVG dimensions
            function handleResize() {
                const newContainerRect = chartContainer.getBoundingClientRect();
                const newWidth = newContainerRect.width - 20;
                const newHeight = newContainerRect.height - 20;
                
                svg.attr('viewBox', `0 0 ${newWidth} ${newHeight}`);
                
                // Update tree layout size
                const layout = (explorerTreeShape === 'cluster' ? d3.cluster() : d3.tree())
                    .size([
                        explorerOrientation === 'vertical' ? newWidth - margin.left - margin.right : newHeight - margin.top - margin.bottom,
                        explorerOrientation === 'vertical' ? newHeight - margin.top - margin.bottom : newWidth - margin.left - margin.right
                    ]);
                
                // Re-run the update if we have data
                if (root) {
                    update(root);
                }
            }
            
            // Debounced resize handler
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleResize, 150);
            });
        }

        // Show field mapping popup menu
        function showFieldMappingPopup(jsonPath, x, y) {
            // Remove any existing popup
            const existingPopup = document.getElementById('fieldMappingPopup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            if (!currentGraphType) {
                showStatus('Please select a graph type first', 'warning');
                return;
            }
            
            // Check if this is an array path and suggest row mapping
            const isArrayPath = jsonPath.includes('[') || (currentApiData && isPathToArray(jsonPath));
            
            // Get available fields for current graph type
            const graphRequirements = {
                'tree': {
                    required: [
                        { role: 'label', name: 'Label', description: '', dataType: 'any' }
                    ],
                    optional: [
                        { role: 'parent', name: 'Parent', description: '', dataType: 'any' },
                        { role: 'value', name: 'Value', description: 'Numeric', dataType: 'number' }
                    ]
                },
                'force-directed': {
                    required: [
                        { role: 'source', name: 'Source', description: '', dataType: 'any' },
                        { role: 'target', name: 'Target', description: '', dataType: 'any' }
                    ],
                    optional: [
                        { role: 'weight', name: 'Weight', description: '', dataType: 'number' },
                        { role: 'label', name: 'Label', description: '', dataType: 'any' }
                    ]
                },
                'bar-chart': {
                    required: [
                        { role: 'x', name: 'X-Axis (Category)', description: '', dataType: 'any' },
                        { role: 'y', name: 'Y-Axis (Value)', description: '', dataType: 'number' }
                    ],
                    optional: [
                        { role: 'color', name: 'Color', description: '', dataType: 'any' },
                        { role: 'tooltip', name: 'Tooltip', description: '', dataType: 'any' }
                    ]
                },
                'world-map': {
                    required: [
                        { role: 'longitude', name: 'Longitude', description: '', dataType: 'number' },
                        { role: 'latitude', name: 'Latitude', description: '', dataType: 'number' },
                        { role: 'label', name: 'Label', description: '', dataType: 'any' }
                    ],
                    optional: [
                        { role: 'value', name: 'Value', description: 'Numeric', dataType: 'number' },
                        { role: 'color', name: 'Color', description: '', dataType: 'any' },
                        { role: 'capital', name: 'Capital', description: '', dataType: 'any' },
                        { role: 'income', name: 'Income', description: '', dataType: 'any' },
                        { role: 'region', name: 'Region', description: '', dataType: 'any' }
                    ]
                }
            };
            
            const requirements = graphRequirements[currentGraphType];
            if (!requirements) return;
            
            // Create popup element
            const popup = document.createElement('div');
            popup.id = 'fieldMappingPopup';
            popup.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #2d2d2d;
                border: 2px solid #007bff;
                border-radius: 8px;
                padding: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                z-index: 1000;
                min-width: 260px;
                max-width: 90vw;
                max-height: 90vh;
                overflow-y: auto;
                font-family: inherit;
            `;
            
            // Create popup content
            let html = `
                <div style="color: #fff; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 6px;">
                    Map "${jsonPath}" to:
                </div>
            `;
            
            // Analyze field data type for display
            let fieldDataType = 'unknown';
            let fieldSample = '';
            if (!isArrayPath && graphMappings.rowPath) {
                // Get relative path for data type analysis
                let relativePath = jsonPath;
                if (jsonPath.startsWith(graphMappings.rowPath)) {
                    relativePath = jsonPath.substring(graphMappings.rowPath.length + 1);
                    
                    // If the remaining path starts with an array index (like "0.wb:longitude"),
                    // remove the array index part to get just the field name (like "wb:longitude")
                    if (relativePath.match(/^\d+\./)) {
                        relativePath = relativePath.substring(relativePath.indexOf('.') + 1);
                    }
                }
                fieldDataType = analyzeFieldDataType(relativePath);
                
                // Get sample values
                const rowDataArray = resolvePath(graphMappings.rowPath);
                if (Array.isArray(rowDataArray) && rowDataArray.length > 0) {
                    const sampleValue = resolvePath(relativePath, rowDataArray[0]);
                    if (sampleValue !== null && sampleValue !== undefined) {
                        fieldSample = String(sampleValue);
                    }
                }
            }
            
            // Show field type info if not an array
            if (!isArrayPath && fieldDataType !== 'unknown') {
                html += `
                    <div style="margin-bottom: 12px; padding: 6px; background: #1a1a1a; border-radius: 4px; border: 1px solid #666;">
                        <div style="color: #ccc; font-size: 11px; margin-bottom: 2px;">
                            <strong>Field Type:</strong> <span style="color: #4fc3f7;">${fieldDataType}</span>
                            ${fieldSample ? `<br><strong>Sample:</strong> "${fieldSample}"` : ''}
                        </div>
                    </div>
                `;
            }
            
            // Add special option for row path (if this is an array)
            if (isArrayPath) {
                html += `
                    <div style="margin-bottom: 12px; padding: 8px; background: #1a1a1a; border-radius: 4px; border: 1px solid #ffc107;">
                        <div style="color: #ffc107; font-size: 12px; font-weight: bold; margin-bottom: 4px;"> Array Data Source:</div>
                        <div class="popup-field-option" data-role="rowPath" style="
                            padding: 6px 8px;
                            margin: 2px 0;
                            background: #444;
                            border-radius: 4px;
                            cursor: pointer;
                            color: #fff;
                            font-size: 13px;
                            border: 1px solid transparent;
                        ">
                            <strong>Set as Row Data Source</strong>
                            <div style="font-size: 11px; color: #ccc;">Each item in this array becomes a row</div>
                        </div>
                    </div>
                `;
            }
            
            // Add required fields
            if (requirements.required.length > 0) {
                html += '<div style="margin-bottom: 8px;">';
                html += '<div style="color: #dc3545; font-size: 12px; font-weight: bold; margin-bottom: 4px;">Required Fields:</div>';
                requirements.required.forEach(field => {
                    // Check compatibility for this field with conversion support
                    let compatibilityResult = { compatible: true, needsConversion: false };
                    let warningMessage = '';
                    let infoMessage = '';
                    
                    if (!isArrayPath && field.dataType && fieldDataType !== 'unknown') {
                        compatibilityResult = isFieldCompatibleWithConversion(fieldDataType, field.dataType);
                        
                        if (!compatibilityResult.compatible) {
                            if (compatibilityResult.conversionInfo) {
                                warningMessage = `Cannot convert: Only ${compatibilityResult.conversionInfo.successCount}/${compatibilityResult.conversionInfo.totalCount} values can be converted to ${field.dataType}.`;
                            } else {
                                warningMessage = `This field contains ${fieldDataType} data, but ${field.name} requires ${field.dataType} data.`;
                            }
                        } else if (compatibilityResult.needsConversion) {
                            infoMessage = ` Can convert string values to ${field.dataType} (${compatibilityResult.conversionInfo.successCount}/${compatibilityResult.conversionInfo.totalCount} convertible)`;
                        }
                    }
                    
                    const isSelected = graphMappings[field.role] === jsonPath;
                    const backgroundColor = isSelected ? '#4fc3f7' : 
                                          compatibilityResult.compatible ? '#444' : '#6a2828';
                    const textColor = isSelected ? '#000' : 
                                     compatibilityResult.compatible ? '#fff' : '#ff9999';
                    const borderColor = isSelected ? 'transparent' : 
                                       compatibilityResult.compatible ? 'transparent' : '#ff6666';
                    
                    html += `
                        <div class="popup-field-option" data-role="${field.role}" style="
                            padding: 6px 8px;
                            margin: 2px 0;
                            background: ${backgroundColor};
                            border-radius: 4px;
                            cursor: pointer;
                            color: ${textColor};
                            font-size: 13px;
                            border: 1px solid ${borderColor};
                        " title="${warningMessage}">
                            <strong>${field.name}</strong>
                            <div style="font-size: 11px; color: ${isSelected ? '#333' : '#ccc'};">${field.description}</div>
                            ${field.dataType && field.dataType !== 'any' ? `<div style="font-size: 10px; color: ${isSelected ? '#333' : '#888'}; margin-top: 2px;">Requires: ${field.dataType}</div>` : ''}
                            ${!compatibilityResult.compatible && !compatibilityResult.needsConversion ? `<div style="font-size: 10px; color: #ff9999; margin-top: 2px;"> ${warningMessage}</div>` : ''}
                            ${compatibilityResult.needsConversion ? `<div style="font-size: 10px; color: #32cd32; margin-top: 2px;">${infoMessage}</div>` : ''}
                            ${isSelected ? '<div style="font-size: 10px; color: #000; margin-top: 2px;"> Currently mapped</div>' : ''}
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            // Add optional fields
            if (requirements.optional.length > 0) {
                html += '<div style="margin-bottom: 8px;">';
                html += '<div style="color: #17a2b8; font-size: 12px; font-weight: bold; margin-bottom: 4px;">Optional Fields:</div>';
                requirements.optional.forEach(field => {
                    // Check compatibility for this field using new conversion-aware function
                    let compatibilityResult = {compatible: true, needsConversion: false, conversionInfo: null};
                    let warningMessage = '';
                    let infoMessage = '';
                    
                    if (!isArrayPath && field.dataType && fieldDataType !== 'unknown') {
                        compatibilityResult = isFieldCompatibleWithConversion(fieldDataType, field.dataType);
                        if (!compatibilityResult.compatible && !compatibilityResult.needsConversion) {
                            warningMessage = `This field contains ${fieldDataType} data, but ${field.name} requires ${field.dataType} data.`;
                        } else if (compatibilityResult.needsConversion) {
                            infoMessage = ` Can convert string values to ${field.dataType} (${compatibilityResult.conversionInfo.successCount}/${compatibilityResult.conversionInfo.totalCount} convertible)`;
                        }
                    }
                    
                    const isSelected = graphMappings[field.role] === jsonPath;
                    const backgroundColor = isSelected ? '#4fc3f7' : 
                                          compatibilityResult.compatible ? '#444' : '#6a2828';
                    const textColor = isSelected ? '#000' : 
                                     compatibilityResult.compatible ? '#fff' : '#ff9999';
                    const borderColor = isSelected ? 'transparent' : 
                                       compatibilityResult.compatible ? 'transparent' : '#ff6666';
                    
                    html += `
                        <div class="popup-field-option" data-role="${field.role}" style="
                            padding: 6px 8px;
                            margin: 2px 0;
                            background: ${backgroundColor};
                            border-radius: 4px;
                            cursor: pointer;
                            color: ${textColor};
                            font-size: 13px;
                            border: 1px solid ${borderColor};
                        " title="${warningMessage}">
                            <strong>${field.name}</strong>
                            <div style="font-size: 11px; color: ${isSelected ? '#333' : '#ccc'};">${field.description}</div>
                            ${field.dataType && field.dataType !== 'any' ? `<div style="font-size: 10px; color: ${isSelected ? '#333' : '#888'}; margin-top: 2px;">Requires: ${field.dataType}</div>` : ''}
                            ${!compatibilityResult.compatible && !compatibilityResult.needsConversion ? `<div style="font-size: 10px; color: #ff9999; margin-top: 2px;"> ${warningMessage}</div>` : ''}
                            ${compatibilityResult.needsConversion ? `<div style="font-size: 10px; color: #32cd32; margin-top: 2px;">${infoMessage}</div>` : ''}
                            ${isSelected ? '<div style="font-size: 10px; color: #000; margin-top: 2px;"> Currently mapped</div>' : ''}
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            // Add cancel button
            html += `
                <div style="border-top: 1px solid #444; padding-top: 8px; margin-top: 8px;">
                    <button id="popupCancel" style="
                        background: #6c757d;
                        color: white;
                        border: none;
                        padding: 4px 12px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        width: 100%;
                    ">Cancel</button>
                </div>
            `;
            
            popup.innerHTML = html;
            document.body.appendChild(popup);
            
            // Add event listeners
            popup.querySelectorAll('.popup-field-option').forEach(option => {
                option.addEventListener('mouseenter', function() {
                    this.style.background = '#007bff';
                    this.style.borderColor = '#007bff';
                });
                
                option.addEventListener('mouseleave', function() {
                    this.style.background = '#444';
                    this.style.borderColor = 'transparent';
                });
                
                option.addEventListener('click', function() {
                    const role = this.dataset.role;
                    
                    if (role === 'rowPath') {
                        // Set this as the row data source
                        const cleanPath = cleanArrayPath(jsonPath);
                        graphMappings.rowPath = cleanPath;
                        
                        // Update row path input (it should already exist)
                        let rowPathInput = document.querySelector('[data-role="rowPath"]');
                        if (rowPathInput) {
                            rowPathInput.value = cleanPath;
                            rowPathInput.dispatchEvent(new Event('change'));
                        }
                        
                        showStatus(`Set ${cleanPath} as row data source`, 'success');
                    } else {
                        // Map to visualization field
                        const input = document.querySelector(`[data-role="${role}"]`);
                        if (input) {
                            // Find the field requirement to check data type compatibility
                            const allFields = [...requirements.required, ...requirements.optional];
                            const fieldRequirement = allFields.find(f => f.role === role);
                            
                            // If we have a row path, make this a relative path
                            let finalPath = jsonPath;
                            if (graphMappings.rowPath && jsonPath.startsWith(graphMappings.rowPath)) {
                                // Remove the row path prefix
                                finalPath = jsonPath.substring(graphMappings.rowPath.length + 1);
                                
                                // If the remaining path starts with an array index (like "0.wb:longitude"),
                                // remove the array index part to get just the field name (like "wb:longitude")
                                if (finalPath.match(/^\d+\./)) {
                                    finalPath = finalPath.substring(finalPath.indexOf('.') + 1);
                                }
                            }
                            
                            // If this field requires a number, attempt server-side validation
                            if (fieldRequirement && fieldRequirement.dataType === 'number') {
                                // Check if we have a row path set
                                if (!graphMappings.rowPath) {
                                    showStatus(` Please set a row data source first before mapping numeric fields`, 'warning');
                                    popup.remove();
                                    return;
                                }
                                
                                // Ensure data source; fall back to selector value if not yet stored in graphMappings
                                if (!graphMappings.dataSource) {
                                    const sel = document.getElementById('apiResponseSelector');
                                    if (sel && sel.value) {
                                        graphMappings.dataSource = sel.value;
                                    }
                                }
                                if (!graphMappings.dataSource) {
                                    showStatus(` Please choose an API Response file first`, 'warning');
                                    popup.remove();
                                    return;
                                }
                                
                                console.log('Validating field with server API:', {
                                    originalPath: jsonPath,
                                    finalPath: finalPath,
                                    rowPath: graphMappings.rowPath,
                                    dataSource: graphMappings.dataSource,
                                    fieldRequirement: fieldRequirement
                                });
                                
                                // Use server-side validation for more reliable results
                                fetch('/ValidateNodeDataType', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        fieldPath: jsonPath,
                                        rowPath: graphMappings.rowPath,
                                        targetDataType: 'number',
                                        dataSource: graphMappings.dataSource
                                    })
                                })
                                .then(response => response.json())
                                .then(result => {
                                    // Always attempt to map the path regardless of validation outcome
                                    if (result.success) {
                                        if (result.fieldName) {
                                            finalPath = result.fieldName; // prefer cleaned field name
                                        }
                                        if (result.isCompatible) {
                                            showStatus(` Value matches and mapped (${Math.round(result.overallCompatibility * 100)}% compatibility)`, 'success');
                                        } else {
                                            showStatus(` Datatype mismatched but still mapped (${Math.round(result.overallCompatibility * 100)}% compatibility)`, 'warning');
                                        }
                                    } else {
                                        showStatus(` Datatype mismatched but still mapped (validation error: ${result.error || 'Unknown error'})`, 'warning');
                                    }

                                    // Complete the mapping (always)
                                    input.value = finalPath;
                                    input.dispatchEvent(new Event('change'));
                                    showStatus(`Mapped ${finalPath} to ${role}`, 'success');
                                    popup.remove();
                                })
                                .catch(error => {
                                    console.error('Server validation failed:', error);
                                    showStatus(` Datatype mismatched but still mapped (server validation failed)`, 'warning');
                                    // Optional client-side attempt for info only
                                    try {
                                        const conversionResult = attemptFieldConversion(jsonPath, 'number');
                                        if (conversionResult.success) {
                                            finalPath = conversionResult.fieldName || finalPath;
                                            showStatus(` Local numeric parse sample: ${conversionResult.convertedCount}/${conversionResult.totalCount} convertible`, 'info');
                                        }
                                    } catch (_) {}
                                    // Map regardless
                                    input.value = finalPath;
                                    input.dispatchEvent(new Event('change'));
                                    showStatus(`Mapped ${finalPath} to ${role}`, 'success');
                                    popup.remove();
                                });
                                
                                return; // Exit early since we're handling the validation asynchronously
                            }
                            
                            // Validate data type compatibility after conversion
                            if (fieldRequirement && fieldRequirement.dataType !== 'any') {
                                const compatibilityResult = isFieldCompatibleWithConversion(finalPath, fieldRequirement.dataType);
                                if (!compatibilityResult.compatible) {
                                    const fieldDataType = analyzeFieldDataType(finalPath);
                                    showStatus(` Data type mismatch: ${fieldRequirement.name} requires ${fieldRequirement.dataType} data, but this field contains ${fieldDataType} data`, 'warning');
                                    popup.remove();
                                    return;
                                }
                            }
                            
                            input.value = finalPath;
                            input.dispatchEvent(new Event('change'));
                            showStatus(`Mapped ${finalPath} to ${role}`, 'success');
                        }
                    }
                    popup.remove();
                });
            });
            
            // Cancel button
            popup.querySelector('#popupCancel').addEventListener('click', function() {
                popup.remove();
            });
            
            // Close popup when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                });
            }, 100);
        }

        // Helper function to check if a path leads to an array
        function isPathToArray(path) {
            try {
                const value = resolvePath(path);
                return Array.isArray(value);
            } catch {
                return false;
            }
        }

        // Helper function to clean array paths
        function cleanArrayPath(path) {
            // Remove array indices like [0], [1] etc to get the base array path
            return path.replace(/\[\d+\]/g, '');
        }

        // Helper function to analyze data type of a field path
        function analyzeFieldDataType(fieldPath, rowDataArray = null) {
            if (!fieldPath || !currentApiData) return 'unknown';
            
            let dataArray = rowDataArray;
            if (!dataArray && graphMappings.rowPath) {
                dataArray = resolvePath(graphMappings.rowPath);
                if (!Array.isArray(dataArray)) dataArray = null;
            }
            
            if (!dataArray || !dataArray.length) return 'unknown';
            
            // Sample first few items to determine data type
            const sampleSize = Math.min(10, dataArray.length);
            const values = [];
            
            for (let i = 0; i < sampleSize; i++) {
                const value = resolvePath(fieldPath, dataArray[i]);
                if (value !== null && value !== undefined && value !== '') {
                    values.push(value);
                }
            }
            
            if (values.length === 0) return 'empty';
            
            // Analyze the collected values
            let numericCount = 0;
            let stringCount = 0;
            let booleanCount = 0;
            
            values.forEach(val => {
                // More lenient numeric detection for coordinates and decimal numbers
                const numVal = parseFloat(val);
                if (!isNaN(numVal) && isFinite(numVal)) {
                    // Check if it's a valid number format (supports negative, positive, decimals, scientific notation)
                    const valStr = String(val).trim();
                    if (/^-?\d*\.?\d+([eE][+-]?\d+)?$/.test(valStr) || typeof val === 'number') {
                        numericCount++;
                    } else {
                        stringCount++;
                    }
                } else if (typeof val === 'boolean') {
                    booleanCount++;
                } else {
                    stringCount++;
                }
            });
            
            // Determine predominant type
            if (numericCount > values.length * 0.8) return 'number';
            if (booleanCount > values.length * 0.8) return 'boolean';
            if (stringCount > 0) return 'string';
            
            return 'mixed';
        }

        // Helper function to check if field is compatible with required data type
        function isFieldCompatible(fieldPath, requiredDataType) {
            if (requiredDataType === 'any') return true;
            
            const fieldDataType = analyzeFieldDataType(fieldPath);
            
            switch (requiredDataType) {
                case 'number':
                    return fieldDataType === 'number' || fieldDataType === 'mixed';
                case 'string':
                    return fieldDataType === 'string' || fieldDataType === 'mixed';
                case 'boolean':
                    return fieldDataType === 'boolean';
                default:
                    return true;
            }
        }

        // Function to attempt converting string values to numbers for numeric fields
        function attemptNumericConversion(fieldPath, requiredDataType) {
            if (requiredDataType !== 'number') return { canConvert: false, dataType: analyzeFieldDataType(fieldPath) };
            
            let dataArray = null;
            if (graphMappings.rowPath) {
                dataArray = resolvePath(graphMappings.rowPath);
                if (!Array.isArray(dataArray)) dataArray = null;
            }
            
            if (!dataArray || !dataArray.length) return { canConvert: false, dataType: 'unknown' };
            
            // Sample first few items to test conversion
            const sampleSize = Math.min(10, dataArray.length);
            let successfulConversions = 0;
            let totalSamples = 0;
            
            for (let i = 0; i < sampleSize; i++) {
                const value = resolvePath(fieldPath, dataArray[i]);
                if (value !== null && value !== undefined && value !== '') {
                    totalSamples++;
                    
                    // Try to convert to number
                    const numVal = parseFloat(String(value).trim());
                    if (!isNaN(numVal) && isFinite(numVal)) {
                        // Additional validation for string representations of numbers
                        const valStr = String(value).trim();
                        if (/^-?\d*\.?\d+([eE][+-]?\d+)?$/.test(valStr) || typeof value === 'number') {
                            successfulConversions++;
                        }
                    }
                }
            }
            
            if (totalSamples === 0) return { canConvert: false, dataType: 'empty' };
            
            // If 80% or more values can be converted to numbers, consider it convertible
            const conversionRate = successfulConversions / totalSamples;
            const canConvert = conversionRate >= 0.8;
            
            return { 
                canConvert: canConvert, 
                dataType: canConvert ? 'convertible-number' : 'string',
                conversionRate: conversionRate,
                successCount: successfulConversions,
                totalCount: totalSamples
            };
        }

        // Enhanced field compatibility check with conversion support
        function isFieldCompatibleWithConversion(fieldPath, requiredDataType) {
            if (requiredDataType === 'any') return { compatible: true, needsConversion: false };
            
            const originalDataType = analyzeFieldDataType(fieldPath);
            
            // If already compatible, no conversion needed
            if (originalDataType === requiredDataType) {
                return { compatible: true, needsConversion: false, dataType: originalDataType };
            }
            
            // For mixed data types, allow them through
            if (originalDataType === 'mixed') {
                return { compatible: true, needsConversion: false, dataType: originalDataType };
            }
            
            // If we need a number but have string/mixed, try conversion
            if (requiredDataType === 'number' && (originalDataType === 'string' || originalDataType === 'mixed')) {
                const conversionResult = attemptNumericConversion(fieldPath, requiredDataType);
                if (conversionResult.canConvert) {
                    return { 
                        compatible: true, 
                        needsConversion: true, 
                        dataType: conversionResult.dataType,
                        conversionInfo: conversionResult
                    };
                } else {
                    return { 
                        compatible: false, 
                        needsConversion: false, 
                        dataType: originalDataType,
                        conversionInfo: conversionResult
                    };
                }
            }
            
            // For other data types, use original logic
            switch (requiredDataType) {
                case 'string':
                    return { compatible: true, needsConversion: false, dataType: originalDataType }; // Strings can accept most things
                case 'boolean':
                    return { compatible: originalDataType === 'boolean', needsConversion: false, dataType: originalDataType };
                default:
                    return { compatible: true, needsConversion: false, dataType: originalDataType };
            }
        }

        // Function to directly test field access at the selected JSON path
        function testFieldAccess(fullFieldPath) {
            console.log(`Testing direct field access for path: "${fullFieldPath}"`);
            
            try {
                // First, get the exact value at this path
                const directValue = resolvePath(fullFieldPath);
                console.log(`Direct value at path "${fullFieldPath}":`, directValue, typeof directValue);
                
                // If we have a row path set, we need to understand the relationship
                if (graphMappings.rowPath) {
                    console.log(`Row path: "${graphMappings.rowPath}"`);
                    const rowData = resolvePath(graphMappings.rowPath);
                    console.log(`Row data type:`, Array.isArray(rowData) ? `Array with ${rowData.length} items` : typeof rowData);
                    
                    if (Array.isArray(rowData) && rowData.length > 0) {
                        console.log(`First row item structure:`, Object.keys(rowData[0] || {}));
                        
                        // Extract the field name from the full path
                        // Handle different path formats:
                        // Case 1: fullFieldPath is like "response.data.wb:countries.wb:country.0.wb:longitude" and rowPath is like "response.data.wb:countries.wb:country"
                        // Case 2: fullFieldPath is like "data.0.wb:longitude" when using array-based data
                        
                        let fieldName = '';
                        
                        if (fullFieldPath.startsWith(graphMappings.rowPath)) {
                            // Standard case: path starts with row path
                            const remainder = fullFieldPath.substring(graphMappings.rowPath.length + 1);
                            // Remove array index if present (e.g., "0.wb:longitude" -> "wb:longitude")
                            if (remainder.match(/^\d+\./)) {
                                fieldName = remainder.substring(remainder.indexOf('.') + 1);
                            } else {
                                fieldName = remainder;
                            }
                        } else {
                            // Fallback: try to extract field name from paths that don't align perfectly
                            // Look for the pattern: "some.path.{number}.{fieldname}"
                            const pathParts = fullFieldPath.split('.');
                            
                            // Find the last numeric index in the path
                            let lastNumericIndex = -1;
                            for (let i = 0; i < pathParts.length; i++) {
                                if (/^\d+$/.test(pathParts[i])) {
                                    lastNumericIndex = i;
                                }
                            }
                            
                            if (lastNumericIndex >= 0 && lastNumericIndex < pathParts.length - 1) {
                                // Take everything after the last numeric index
                                fieldName = pathParts.slice(lastNumericIndex + 1).join('.');
                            } else {
                                // Last resort: take the last part of the path
                                fieldName = pathParts[pathParts.length - 1];
                            }
                        }
                        
                        console.log(`Extracted field name: "${fieldName}"`);
                        
                        // Test accessing this field in each row item
                        const testResults = [];
                        for (let i = 0; i < Math.min(3, rowData.length); i++) {
                            const item = rowData[i];
                            const fieldValue = resolvePath(fieldName, item);
                            testResults.push({
                                index: i,
                                fieldValue: fieldValue,
                                fieldType: typeof fieldValue
                            });
                            console.log(`Row ${i}, field "${fieldName}":`, fieldValue, typeof fieldValue);
                        }
                        
                        return {
                            success: true,
                            fieldName: fieldName,
                            testResults: testResults,
                            rowDataLength: rowData.length
                        };
                    }
                }
                
                return {
                    success: false,
                    error: 'No valid row data found',
                    directValue: directValue
                };
                
            } catch (error) {
                console.error('Error testing field access:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Function to attempt conversion of field values for mapping to numeric roles
        function attemptFieldConversion(fullFieldPath, targetDataType) {
            if (targetDataType !== 'number') {
                return { success: false, message: 'Only numeric conversions are supported', convertedCount: 0, totalCount: 0 };
            }
            
            console.log(`\n=== Starting conversion test for "${fullFieldPath}" ===`);
            
            // First, test direct field access
            const fieldTest = testFieldAccess(fullFieldPath);
            if (!fieldTest.success) {
                console.log('Field access test failed:', fieldTest.error);
                return { success: false, message: fieldTest.error, convertedCount: 0, totalCount: 0 };
            }
            
            console.log(`Field access test successful. Field name: "${fieldTest.fieldName}"`);
            
            // Get the row data array
            let dataArray = null;
            if (graphMappings.rowPath) {
                dataArray = resolvePath(graphMappings.rowPath);
                if (!Array.isArray(dataArray)) dataArray = null;
            }
            
            if (!dataArray || !dataArray.length) {
                console.log('No data array found. Row path:', graphMappings.rowPath);
                return { success: false, message: 'No data array found', convertedCount: 0, totalCount: 0 };
            }
            
            // Test conversion on all available data using the extracted field name
            let successfulConversions = 0;
            let totalItems = 0;
            let sampleValues = [];
            
            dataArray.forEach((item, index) => {
                const value = resolvePath(fieldTest.fieldName, item);
                
                // Log first few values for debugging
                if (index < 3) {
                    console.log(`Item ${index}, field "${fieldTest.fieldName}":`, value, typeof value);
                    sampleValues.push(value);
                }
                
                if (value !== null && value !== undefined && value !== '') {
                    totalItems++;
                    
                    // Convert value to string and trim
                    let stringValue = String(value).trim();
                    
                    // Handle different possible formats:
                    // 1. If the string contains field name and value (like "wb:longitude: -70.0167")
                    // 2. If it's just the raw value (like "-70.0167")
                    // 3. If it's in some other format
                    
                    if (stringValue.includes(':')) {
                        // Split by colon and take the last numeric-looking part
                        const parts = stringValue.split(':');
                        for (let i = parts.length - 1; i >= 0; i--) {
                            const trimmedPart = parts[i].trim();
                            const testNum = parseFloat(trimmedPart);
                            if (!isNaN(testNum) && isFinite(testNum) && /^-?\d*\.?\d+([eE][-+]?\d+)?$/.test(trimmedPart)) {
                                stringValue = trimmedPart;
                                break;
                            }
                        }
                    }
                    
                    // Skip if still empty after processing
                    if (stringValue === '') {
                        return;
                    }
                    
                    const numValue = parseFloat(stringValue);
                    
                    // Check if conversion was successful
                    if (!isNaN(numValue) && isFinite(numValue)) {
                        // More lenient regex to accept decimal numbers, negative numbers, etc.
                        const isValidNumber = /^-?\d*\.?\d+([eE][-+]?\d+)?$/.test(stringValue);
                        if (isValidNumber) {
                            successfulConversions++;
                            if (index < 3) {
                                console.log(` Successfully converted "${value}" -> "${stringValue}" -> ${numValue}`);
                            }
                        } else {
                            if (index < 3) {
                                console.log(` Failed regex validation for "${stringValue}"`);
                            }
                        }
                    } else {
                        if (index < 3) {
                            console.log(` Failed numeric conversion for "${stringValue}" -> ${numValue}`);
                        }
                    }
                }
            });
            
            console.log(`\n=== Conversion Results ===`);
            console.log(`Total items processed: ${totalItems}`);
            console.log(`Successful conversions: ${successfulConversions}`);
            console.log(`Sample values:`, sampleValues);
            console.log(`=========================\n`);
            
            if (totalItems === 0) {
                return { success: false, message: 'No values found to convert', convertedCount: 0, totalCount: 0 };
            }
            
            // Require at least 80% success rate for conversion
            const conversionRate = successfulConversions / totalItems;
            const success = conversionRate >= 0.8;
            
            return {
                success: success,
                message: success ? 
                    `Successfully converted ${successfulConversions}/${totalItems} values to numbers` :
                    `Only ${successfulConversions}/${totalItems} values could be converted to numbers (${Math.round(conversionRate * 100)}% success rate)`,
                convertedCount: successfulConversions,
                totalCount: totalItems,
                conversionRate: conversionRate,
                fieldName: fieldTest.fieldName
            };
        }

        // Graph type selection
        function selectGraphType() {
            const selector = document.getElementById('graphTypeSelector');
            const newType = selector.value;
            // Persist current mappings into savedGraphMappings before switching
            if (currentGraphType) {
                if (!savedGraphMappings[currentGraphType]) savedGraphMappings[currentGraphType] = { mappings: {} };
                savedGraphMappings[currentGraphType].mappings = { ...graphMappings };
            }
            currentGraphType = newType;
            if (!currentGraphType) {
                hideVariablesPreview();
                updateRenderButtonState();
                return;
            }
            loadGraphMappingControls(currentGraphType, true);
            updateRenderButtonState();
            // Auto-save active graph type change
            scheduleMultiGraphSave();
        }

        // Load mapping controls for selected graph type
        function loadGraphMappingControls(graphType, restoreExisting=false) {
            const container = document.getElementById('mappingControls');
            // Reset current mappings, will repopulate after inputs created
            graphMappings = {};
            
            const graphRequirements = {
                'tree': {
                    required: [
                        { role: 'label', name: 'Label', description: 'Text to display for each node' }
                    ],
                    optional: [
                        { role: 'parent', name: 'Parent', description: 'Parent node reference' },
                        { role: 'value', name: 'Value', description: 'Numeric value for sizing' }
                    ]
                },
                'force-directed': {
                    required: [
                        { role: 'source', name: 'Source', description: 'Source node identifier' },
                        { role: 'target', name: 'Target', description: 'Target node identifier' }
                    ],
                    optional: [
                        { role: 'weight', name: 'Weight', description: 'Connection strength' },
                        { role: 'label', name: 'Label', description: 'Edge label' }
                    ]
                },
                'bar-chart': {
                    required: [
                        { role: 'x', name: 'X-Axis (Category)', description: 'Categories for X-axis' },
                        { role: 'y', name: 'Y-Axis (Value)', description: 'Numeric values for Y-axis' }
                    ],
                    optional: [
                        { role: 'color', name: 'Color', description: 'Category for coloring' },
                        { role: 'tooltip', name: 'Tooltip', description: 'Additional info on hover' }
                    ]
                },
                'world-map': {
                    required: [
                        { role: 'longitude', name: 'Longitude', description: 'Longitude coordinate' },
                        { role: 'latitude', name: 'Latitude', description: 'Latitude coordinate' },
                        { role: 'label', name: 'Label', description: 'Point label (e.g., country name)' }
                    ],
                    optional: [
                        { role: 'value', name: 'Value', description: 'Numeric value (point size/color)' },
                        { role: 'color', name: 'Color', description: 'Color category field' },
                        { role: 'capital', name: 'Capital', description: 'Capital city' },
                        { role: 'income', name: 'Income', description: 'Income level classification' },
                        { role: 'region', name: 'Region', description: 'Geographic region' }
                    ]
                }
            };
            
            const requirements = graphRequirements[graphType];
            if (!requirements) {
                container.innerHTML = '<p class="text-warning">Unknown graph type</p>';
                return;
            }
            
            let html = '';
            
            // Add row path configuration first
            html += `
                <div class="mb-3" style="border: 2px solid #ffc107; border-radius: 6px; padding: 10px; background: #1a1a1a;">
                    <h6 class="text-warning small mb-2"> Data Source Configuration:</h6>
                    <div class="mb-2">
                        <div class="input-container">
                            <input type="text" 
                                   class="form-control" 
                                   data-role="rowPath"
                                   placeholder="Path to array containing row data (e.g., response.data.wb:countries.wb:country)"
                                   style="background: #333; border-color: #ffc107;">
                        </div>
                        <small class="text-muted">
                            <strong>Row Data Source</strong> <span class="text-warning">*</span>
                            - Path to the array where each item becomes a data row
                        </small>
                    </div>
                </div>
            `;
            
            // Required inputs
            if (requirements.required.length > 0) {
                html += '<div class="required-inputs mb-3">';
                html += '<h6 class="text-danger small">Required Fields (relative to each row):</h6>';
                requirements.required.forEach(input => {
                    html += createMappingInput(input, true);
                });
                html += '</div>';
            }
            
            // Optional inputs
            if (requirements.optional.length > 0) {
                html += '<div class="optional-inputs mb-3">';
                html += '<h6 class="text-info small">Optional Fields (relative to each row):</h6>';
                requirements.optional.forEach(input => {
                    html += createMappingInput(input, false);
                });
                html += '</div>';
            }
            
            container.innerHTML = html;
            
            // Add event listeners for input changes
            container.querySelectorAll('.form-control').forEach(input => {
                input.addEventListener('change', function() {
                    const role = this.dataset.role;
                    const path = this.value;
                    graphMappings[role] = path || null;
                    // Keep savedGraphMappings in sync for current graph type
                    if (currentGraphType) {
                        if (!savedGraphMappings[currentGraphType]) savedGraphMappings[currentGraphType] = { mappings: {} };
                        savedGraphMappings[currentGraphType].mappings = { ...graphMappings };
                    }
                    updateRenderButtonState();
                    updateVariablesPreview();
                    scheduleMultiGraphSave();
                });
            });

            // Restore saved mappings for this graph type if present
            if (restoreExisting && savedGraphMappings[graphType] && savedGraphMappings[graphType].mappings) {
                Object.entries(savedGraphMappings[graphType].mappings).forEach(([role, path]) => {
                    graphMappings[role] = path;
                    const input = container.querySelector(`[data-role="${role}"]`);
                    if (input) input.value = path;
                });
                updateVariablesPreview();
            }
            
            // Enable drag from JSON explorer nodes (removed old timeout)
        }

        function createMappingInput(input, required) {
            return `
                <div class="mb-2">
                    <div class="input-container">
                        <input type="text" 
                               class="form-control" 
                               data-role="${input.role}"
                               placeholder=""
                               ${required ? 'required' : ''}>
                    </div>
                    <small class="text-muted">
                        <strong>${input.name}</strong> ${required ? '<span class="text-danger">*</span>' : ''}
                        - ${input.description}
                    </small>
                </div>
            `;
        }

        // Preview mappings
        function previewMappings() {
            if (!currentApiData || Object.keys(graphMappings).length === 0) {
                showStatus('No mappings to preview', 'error');
                return;
            }
            updateVariablesPreview();
            showVariablesPreview();
        }

        function updateVariablesPreview() {
            const tableContainer = document.getElementById('variablesTable');
            if (!tableContainer) return;
            if (!currentApiData || Object.keys(graphMappings).length === 0) {
                hideVariablesPreview();
                return;
            }
            const preview = buildPreviewData();
            if (!preview.rows.length) {
                tableContainer.innerHTML = '<div class="text-warning small">No preview rows available for current mappings.</div>';
                return;
            }
            let html = '<table class="table table-sm table-dark mb-0"><thead><tr>';
            preview.columns.forEach(col => { html += `<th>${col}</th>`; });
            html += '</tr></thead><tbody>';
            preview.rows.forEach(r => {
                html += '<tr>' + preview.columns.map(c => `<td>${formatPreviewCell(r[c])}</td>`).join('') + '</tr>';
            });
            html += '</tbody></table>';
            html += `<div class="small text-muted mt-1">Showing ${preview.rows.length} row(s)${preview.truncated ? ' (truncated)' : ''}.</div>`;
            tableContainer.innerHTML = html;
            showVariablesPreview();
        }
        function formatPreviewCell(val){
            if (val === null || val === undefined) return '<span class="text-secondary"></span>';
            if (typeof val === 'object') return `<code>${JSON.stringify(val).substring(0,60)}${JSON.stringify(val).length>60?'':''}</code>`;
            const s = String(val);
            return s.length>60 ? s.substring(0,60)+'' : s;
        }
        function resolvePath(pathExpr, baseData = null) {
            try {
                if (!pathExpr) return undefined;
                const data = baseData || currentApiData;
                const segments = pathExpr.split('.');
                let cur = data;
                for (let seg of segments) {
                    if (!cur) return undefined;
                    if (seg.includes('[')) {
                        const base = seg.substring(0, seg.indexOf('['));
                        const idx = parseInt(seg.substring(seg.indexOf('[')+1, seg.indexOf(']')));
                        cur = cur[base];
                        cur = Array.isArray(cur) ? cur[idx] : undefined;
                    } else {
                        cur = cur[seg];
                    }
                }
                return cur;
            } catch { return undefined; }
        }
        
        function buildPreviewData(){
            const columns = Object.keys(graphMappings).filter(k => graphMappings[k] && k !== 'rowPath');
            if (!columns.length) return { columns: [], rows: [], truncated: false };
            
            // Get the row data array
            let rowDataArray = [];
            if (graphMappings.rowPath) {
                const rowData = resolvePath(graphMappings.rowPath);
                if (Array.isArray(rowData)) {
                    rowDataArray = rowData;
                } else {
                    console.warn('Row path does not point to an array:', graphMappings.rowPath);
                    return { columns, rows: [], truncated: false };
                }
            } else {
                // Fallback: try to find arrays in mapped paths
                for (const role of columns) {
                    const pathValue = resolvePath(graphMappings[role]);
                    if (Array.isArray(pathValue)) {
                        rowDataArray = pathValue;
                        break;
                    }
                }
            }
            
            if (!rowDataArray.length) {
                return { columns, rows: [], truncated: false };
            }
            
            const limit = 20;
            const rows = [];
            
            for (let i = 0; i < Math.min(rowDataArray.length, limit); i++) {
                const rowItem = rowDataArray[i];
                const row = {};
                
                columns.forEach(role => {
                    const fieldPath = graphMappings[role];
                    if (fieldPath) {
                        // Resolve field path relative to this row item
                        row[role] = resolvePath(fieldPath, rowItem);
                    }
                });
                
                rows.push(row);
            }
            
            return { columns, rows, truncated: rowDataArray.length > limit };
        }

        // Schedule save for explorer-only changes (legacy)
        function autoSaveGraphControls() {
            scheduleMultiGraphSave();
        }

        function scheduleMultiGraphSave() {
            clearTimeout(saveExplorerConfigDebounce);
            saveExplorerConfigDebounce = setTimeout(() => {
                if (currentGraphType) {
                    if (!savedGraphMappings[currentGraphType]) savedGraphMappings[currentGraphType] = { mappings: {} };
                    savedGraphMappings[currentGraphType].mappings = { ...graphMappings };
                }
                const payload = {
                    dataSource: graphMappings.dataSource ? { apiResponse: graphMappings.dataSource } : undefined,
                    visualization: {
                        activeGraphType: currentGraphType,
                        graphs: savedGraphMappings
                    },
                    explorerSettings: {
                        spacing: explorerSpacing,
                        verticalSpacing: explorerVerticalSpacing,
                        textSize: explorerTextSize,
                        maxDepth: explorerMaxDepth
                    }
                };
                fetch('/SaveGraphControls', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }).catch(()=>{});
            }, 400);
        }
        async function loadExplorerControlsFromGraphconf() {
            try {
                const resp = await fetch('/Graphconf.json');
                if (!resp.ok) return;
                const conf = await resp.json();
                if (conf.explorerControls) {
                    const ec = conf.explorerControls;
                    explorerSpacing = ec.nodeSpacing ?? explorerSpacing;
                    explorerVerticalSpacing = ec.verticalSpacing ?? explorerVerticalSpacing;
                    explorerTextSize = ec.textSize ?? explorerTextSize;
                    explorerNodeSize = ec.nodeSize ?? explorerNodeSize;
                    explorerMaxDepth = ec.maxDepth ?? explorerMaxDepth;
                    explorerChartSize = ec.chartSize ?? explorerChartSize;
                    explorerOrientation = ec.orientation ?? explorerOrientation;
                    explorerTreeShape = ec.treeShape ?? explorerTreeShape;
                    explorerLinkStyle = ec.linkStyle ?? explorerLinkStyle;
                    explorerShowLabels = ec.showLabels ?? explorerShowLabels;
                    // Apply UI values
                    document.getElementById('explorerSpacingSlider').value = explorerSpacing;
                    document.getElementById('explorerSpacingValue').textContent = explorerSpacing;
                    document.getElementById('explorerVerticalSpacingSlider').value = explorerVerticalSpacing;
                    document.getElementById('explorerVerticalSpacingValue').textContent = explorerVerticalSpacing;
                    document.getElementById('explorerTextSizeSlider').value = explorerTextSize;
                    document.getElementById('explorerTextSizeValue').textContent = explorerTextSize;
                    document.getElementById('explorerNodeSizeSlider').value = explorerNodeSize;
                    document.getElementById('explorerNodeSizeValue').textContent = explorerNodeSize;
                    document.getElementById('explorerMaxDepthSlider').value = explorerMaxDepth;
                    document.getElementById('explorerMaxDepthValue').textContent = explorerMaxDepth;
                    document.getElementById('explorerChartSizeSlider').value = explorerChartSize;
                    document.getElementById('explorerChartSizeValue').textContent = explorerChartSize;
                    document.getElementById('explorerOrientationSelect').value = explorerOrientation;
                    document.getElementById('explorerTreeShapeSelect').value = explorerTreeShape;
                    document.getElementById('explorerLinkStyleSelect').value = explorerLinkStyle;
                    document.getElementById('explorerShowLabelsChk').checked = explorerShowLabels;
                }
            } catch(e) { console.warn('Failed to load explorer controls', e); }
        }
        // Restore previously saved RenderGraph configuration (GraphControls.json)
        async function loadSavedConfiguration() {
            try {
                const response = await fetch('/data/GraphControls.json');
                if (!response.ok) return; // silently ignore if not present
                const config = await response.json();
                // Multi-graph: capture saved graphs
                if (config.visualization && config.visualization.graphs) {
                    savedGraphMappings = config.visualization.graphs;
                }
                // Restore data source
                if (config.dataSource && config.dataSource.apiResponse) {
                    const sel = document.getElementById('apiResponseSelector');
                    // Wait until options loaded
                    const ensureOption = () => {
                        if ([...sel.options].some(o => o.value === config.dataSource.apiResponse)) {
                            sel.value = config.dataSource.apiResponse;
                            loadSelectedApiResponse();
                        } else {
                            setTimeout(ensureOption, 200);
                        }
                    };
                    ensureOption();
                }
                // Visualization
                // Determine initial active graph type
                let initialType = config.visualization?.activeGraphType || config.visualization?.graphType;
                if (initialType === 'map') initialType = 'world-map';
                if (!initialType && config.visualization?.graphs) {
                    const keys = Object.keys(config.visualization.graphs);
                    if (keys.length) initialType = keys[0];
                }
                if (initialType) {
                    const selector = document.getElementById('graphTypeSelector');
                    selector.value = initialType;
                    currentGraphType = initialType;
                    loadGraphMappingControls(initialType, true);
                }
                updateRenderButtonState();
                // Explorer settings (subset stored in GraphControls.json)
                if (config.explorerSettings) {
                    if (config.explorerSettings.spacing !== undefined) {
                        explorerSpacing = config.explorerSettings.spacing;
                        document.getElementById('explorerSpacingSlider').value = explorerSpacing;
                        document.getElementById('explorerSpacingValue').textContent = explorerSpacing;
                    }
                    if (config.explorerSettings.verticalSpacing !== undefined) {
                        explorerVerticalSpacing = config.explorerSettings.verticalSpacing;
                        document.getElementById('explorerVerticalSpacingSlider').value = explorerVerticalSpacing;
                        document.getElementById('explorerVerticalSpacingValue').textContent = explorerVerticalSpacing;
                    }
                    if (config.explorerSettings.textSize !== undefined) {
                        explorerTextSize = config.explorerSettings.textSize;
                        document.getElementById('explorerTextSizeSlider').value = explorerTextSize;
                        document.getElementById('explorerTextSizeValue').textContent = explorerTextSize;
                    }
                    if (config.explorerSettings.maxDepth !== undefined) {
                        explorerMaxDepth = config.explorerSettings.maxDepth;
                        document.getElementById('explorerMaxDepthSlider').value = explorerMaxDepth;
                        document.getElementById('explorerMaxDepthValue').textContent = explorerMaxDepth;
                    }
                }
            } catch (err) {
                console.warn('No previous configuration to load', err);
            }
        }
        // Status indicator helper
        function showStatus(message, type) {
            const indicator = document.getElementById('statusIndicator');
            if (!indicator) return;
            indicator.textContent = message;
            
            // Remove existing classes
            indicator.classList.remove('bg-success', 'bg-danger', 'bg-info', 'text-white', 'opacity-0');
            
            // Add appropriate Bootstrap classes based on type
            const colorClass = type === 'success' ? 'bg-success' : 
                              type === 'error' ? 'bg-danger' : 'bg-info';
            indicator.className = `position-fixed p-3 rounded text-white ${colorClass}`;
            indicator.style.top = '80px';
            indicator.style.right = '20px';
            indicator.style.zIndex = '1001';
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 3000);
        }

        // Explorer button functions
        function expandAllExplorerNodes() {
            if (explorerRoot && explorerUpdate) {
                explorerRoot.descendants().forEach(d => {
                    if (d._children) {
                        d.children = d._children;
                        d._children = null;
                    }
                });
                explorerUpdate(explorerRoot);
            }
        }

        function collapseAllExplorerNodes() {
            if (explorerRoot && explorerUpdate) {
                explorerRoot.descendants().forEach(d => {
                    if (d.depth > 1 && d.children) {
                        d._children = d.children;
                        d.children = null;
                    }
                });
                explorerUpdate(explorerRoot);
            }
        }

        function centerExplorerView() {
            if (explorerZoom && d3.select('#jsonExplorerChart svg').node()) {
                const svg = d3.select('#jsonExplorerChart svg');
                const bounds = svg.select('g').node().getBBox();
                
                // Get dimensions from viewBox or container
                const viewBox = svg.attr('viewBox');
                let svgWidth, svgHeight;
                
                if (viewBox) {
                    const [,, width, height] = viewBox.split(' ').map(Number);
                    svgWidth = width;
                    svgHeight = height;
                } else {
                    // Fallback to container dimensions
                    const containerRect = document.getElementById('jsonExplorerChart').getBoundingClientRect();
                    svgWidth = containerRect.width;
                    svgHeight = containerRect.height;
                }
                
                const centerX = svgWidth / 2;
                const centerY = svgHeight / 2;
                const x = centerX - bounds.x - bounds.width / 2;
                const y = centerY - bounds.y - bounds.height / 2;
                
                svg.transition().duration(750)
                    .call(explorerZoom.transform, d3.zoomIdentity.translate(x, y));
            }
        }

        // Missing utility functions
        function getSampleDataFromPath(path) {
            try {
                const keys = path.split('.');
                let current = currentApiData;
                
                for (let key of keys) {
                    if (key.includes('[') && key.includes(']')) {
                        const arrayKey = key.split('[')[0];
                        const index = parseInt(key.split('[')[1].split(']')[0]) || 0;
                        current = current[arrayKey] ? current[arrayKey][index] : undefined;
                    } else {
                        current = current[key];
                    }
                    
                    if (current === undefined) break;
                }
                
                return current;
            } catch (error) {
                return undefined;
            }
        }

        function showVariablesPreview() {
            document.getElementById('variablesPreview').classList.remove('d-none');
        }

        function hideVariablesPreview() {
            document.getElementById('variablesPreview').classList.add('d-none');
        }

        function clearAllMappings() {
            graphMappings = {};
            document.querySelectorAll('.form-control').forEach(input => {
                input.value = '';
                // Remove drop-zone class logic since we no longer use drop zones
            });
            hideVariablesPreview();
            updateRenderButtonState();
        }

        // Explorer control update functions
        function updateExplorerSpacing(value) {
            explorerSpacing = parseInt(value);
            document.getElementById('explorerSpacingValue').textContent = value;
            if (explorerUpdate && explorerRoot) {
                explorerUpdate(explorerRoot);
            }
            persistExplorerControls();
        }

        function updateExplorerVerticalSpacing(value) {
            explorerVerticalSpacing = parseInt(value);
            document.getElementById('explorerVerticalSpacingValue').textContent = value;
            if (explorerUpdate && explorerRoot) {
                explorerUpdate(explorerRoot);
            }
            persistExplorerControls();
        }

        function updateExplorerTextSize(value) {
            explorerTextSize = parseInt(value);
            document.getElementById('explorerTextSizeValue').textContent = value;
            if (currentApiData) {
                displayJsonExplorer(currentApiData);
            }
            persistExplorerControls();
        }

        function updateExplorerMaxDepth(value) {
            explorerMaxDepth = parseInt(value);
            document.getElementById('explorerMaxDepthValue').textContent = value;
            if (currentApiData) {
                displayJsonExplorer(currentApiData);
            }
            persistExplorerControls();
        }

        function updateExplorerNodeSize(value) {
            explorerNodeSize = parseInt(value);
            document.getElementById('explorerNodeSizeValue').textContent = value;
            if (explorerUpdate && explorerRoot) explorerUpdate(explorerRoot);
            persistExplorerControls();
        }

        function updateExplorerOrientation(value) {
            explorerOrientation = value;
            if (currentApiData) displayJsonExplorer(currentApiData);
            persistExplorerControls();
        }

        function updateExplorerTreeShape(value) {
            explorerTreeShape = value;
            if (currentApiData) displayJsonExplorer(currentApiData);
            persistExplorerControls();
        }

        function updateExplorerLinkStyle(value) {
            explorerLinkStyle = value;
            if (explorerUpdate && explorerRoot) explorerUpdate(explorerRoot);
            persistExplorerControls();
        }

        function updateExplorerShowLabels(checked) {
            explorerShowLabels = checked;
            if (explorerUpdate && explorerRoot) explorerUpdate(explorerRoot);
            persistExplorerControls();
        }

        function updateExplorerChartSize(value) {
            explorerChartSize = parseInt(value);
            document.getElementById('explorerChartSizeValue').textContent = value;
            if (currentApiData) displayJsonExplorer(currentApiData);
            persistExplorerControls();
        }

        function persistExplorerControls() {
            clearTimeout(saveExplorerConfigDebounce);
            saveExplorerConfigDebounce = setTimeout(() => {
                const payload = {
                    explorerControls: {
                        nodeSpacing: explorerSpacing,
                        verticalSpacing: explorerVerticalSpacing,
                        textSize: explorerTextSize,
                        nodeSize: explorerNodeSize,
                        maxDepth: explorerMaxDepth,
                        chartSize: explorerChartSize,
                        orientation: explorerOrientation,
                        treeShape: explorerTreeShape,
                        linkStyle: explorerLinkStyle,
                        showLabels: explorerShowLabels,
                        lastUpdated: new Date().toISOString()
                    }
                };
                fetch('/UpdateGraphControls', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }).catch(()=>{});
            }, 400);
        }

        // Render graph function
        async function renderGraph() {
            if (!currentApiData || !currentGraphType) {
                showStatus('Please select both an API response and graph type', 'error');
                return;
            }
            
            try {
                showStatus('Saving configuration...', 'info');
                
                // Build multi-graph structure (merge existing if any)
                let existingCfg = null;
                try {
                    const existingResp = await fetch('../data/GraphControls.json?_=' + Date.now());
                    if (existingResp.ok) existingCfg = await existingResp.json();
                } catch {}
                let graphs = existingCfg?.visualization?.graphs || {};
                if (!graphs[currentGraphType]) graphs[currentGraphType] = { mappings: {} };
                graphs[currentGraphType].mappings = { ...graphMappings };
                const configuration = {
                    dataSource: {
                        apiResponse: document.getElementById('apiResponseSelector').value
                    },
                    visualization: {
                        activeGraphType: currentGraphType,
                        graphs: graphs
                    },
                    explorerSettings: {
                        spacing: explorerSpacing,
                        verticalSpacing: explorerVerticalSpacing,
                        textSize: explorerTextSize,
                        maxDepth: explorerMaxDepth
                    },
                    timestamp: new Date().toISOString()
                };
                
                const response = await fetch('/RenderGraph', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(configuration)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                showStatus('Configuration saved successfully!', 'success');
                
                // Redirect to view page after a brief delay
                setTimeout(() => {
                    window.location.href = 'Graph.html';
                }, 1500);
                
            } catch (error) {
                console.error('Error saving configuration:', error);
                showStatus('Failed to save configuration', 'error');
            }
        }
    </script>
</body>
</html>
